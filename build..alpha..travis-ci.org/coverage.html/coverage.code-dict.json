{"/home/travis/build/npmtest/node-npmtest-csscomb/test.js":"/* istanbul instrument in package npmtest_csscomb */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireExampleJsFromReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-csscomb/lib.npmtest_csscomb.js":"/* istanbul instrument in package npmtest_csscomb */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_csscomb = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_csscomb = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-csscomb/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-csscomb && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_csscomb */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_csscomb\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_csscomb.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_csscomb.rollup.js'] =\n            local.assetsDict['/assets.npmtest_csscomb.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_csscomb.__dirname + '/lib.npmtest_csscomb.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-csscomb/node_modules/csscomb/lib/csscomb.js":"'use strict';\n\nlet gonzales = require('gonzales-pe');\nlet fs = require('fs');\nlet Comb = require('./core');\nlet format = require('./format');\nlet path = require('path');\n\n/**\n * @param {String|Object} config\n * @constructor\n * @name CSScomb\n */\nlet CSScomb = function (config) {\n  let comb = new Comb();\n\n  // Add plugins.\n  fs.readdirSync(__dirname + '/options').map(function (option) {\n    return require('./options/' + option);\n  }).forEach(function (option) {\n    comb.use(option);\n  });\n\n  // If config was passed, configure:\n  if (typeof config === 'string') {\n    config = CSScomb.getConfig(config);\n  }\n  if (typeof config === 'object') {\n    comb.configure(config);\n  }\n\n  // Chaining.\n  return comb;\n};\n\n/**\n * STATIC METHODS\n * Methods that can be called without creating an instance:\n *   - detectInFile;\n *   - detectInString;\n *   - getConfig;\n *   - getCustomConfig;\n *   - getCustomConfigPath;\n * For example: `CSScomb.getConfig('zen')`\n */\n\n/**\n * Detects the options in the given file\n *\n * @param {String} file Path to the stylesheet\n * @param {Array} options List of options to detect\n * @returns {Object} Detected options\n */\nCSScomb.detectInFile = function detectInFile(file, options) {\n  var stylesheet = fs.readFileSync(file, 'utf8');\n  return CSScomb.detectInString(stylesheet, options);\n};\n\n/**\n * Detects the options in the given string\n *\n * @param {String} text Stylesheet\n * @param {Array} options List of options to detect\n * @returns {Object} Detected options\n */\nCSScomb.detectInString = function detectInString(text, options) {\n  var result;\n  var handlers = [];\n\n  if (!text) return text;\n\n  var optionNames = fs.readdirSync(__dirname + '/options');\n  optionNames.forEach(function (option) {\n    option = option.slice(0, -3);\n    if (options && options.indexOf(option) < 0) return;\n    try {\n      handlers.push(getHandler(option));\n    } catch (e) {\n      let message = `\\nFailed to load \"${option}\" option:\\n${e.message}`;\n      console.warn(message);\n    }\n  });\n\n  var tree = cssToAST(text);\n  var detectedOptions = detectInTree(tree, handlers);\n  result = getDetectedOptions(detectedOptions, handlers);\n\n  // Handle conflicting options with spaces around braces:\n  var blockIndent = result['block-indent'];\n  var spaceAfterOpeningBrace = result['space-after-opening-brace'];\n\n  if (typeof blockIndent === 'string' && spaceAfterOpeningBrace && spaceAfterOpeningBrace.indexOf('\\n') > -1) {\n    result['space-after-opening-brace'] = '\\n';\n  }\n\n  return result;\n};\n\n/**\n * Gets one of configuration files from configs' directory.\n *\n * @param {String} name Config's name, e.g. 'yandex'\n * @returns {Object} Configuration object\n */\nCSScomb.getConfig = function getConfig(name) {\n  const DEFAULT_CONFIG_NAME = 'csscomb';\n  name = name || DEFAULT_CONFIG_NAME;\n\n  if (typeof name !== 'string') {\n    throw new Error('Config name must be a string.');\n  }\n\n  let CONFIG_DIR_PATH = '../config';\n  let dir = `${__dirname}/${CONFIG_DIR_PATH}`;\n  let availableConfigsNames = fs.readdirSync(dir).map(function (configFileName) {\n    return configFileName.split('.')[0]; // Strip file extension(s)\n  });\n\n  if (availableConfigsNames.indexOf(name) < 0) {\n    let configsNamesAsString = availableConfigsNames.map(function (configName) {\n      return '\\'' + configName + '\\'';\n    }).join(', ');\n    let message = `\"${name}\" is not a valid config name. Try one\n                   of the following: ${configsNamesAsString}.`;\n    throw new Error(format(message));\n  }\n\n  return require(CONFIG_DIR_PATH + '/' + name + '.json');\n};\n\n/**\n * Gets configuration from provided config path or looks for it in common\n * places.\n *\n * @param {String} [configPath]\n * @returns {Object|null}\n */\nCSScomb.getCustomConfig = function getCustomConfig(configPath) {\n  var config;\n  configPath = configPath || CSScomb.getCustomConfigPath();\n\n  try {\n    config = JSON.parse(fs.readFileSync(configPath, 'utf8'));\n  } catch (e) {\n    config = null;\n  }\n\n  return config;\n};\n\n/**\n * Looks for a config file: recursively from current (process) directory\n * up to $HOME dir\n * If no custom config file is found, return `null`.\n *\n * @param {String} [configPath]\n * @returns {String | null}\n */\nCSScomb.getCustomConfigPath = function getCustomConfigPath(configPath) {\n  var HOME = process.env.HOME || process.env.HOMEPATH || process.env.USERPROFILE;\n\n  configPath = configPath || path.join(process.cwd(), '.csscomb.json');\n\n  // If we've finally found a config, return its path:\n  if (fs.existsSync(configPath)) return fs.realpathSync(configPath);\n\n  // If we are in HOME dir already and yet no config file, return a default\n  // one from our package.\n  // If project is located not under HOME, compare to root instead.\n  // Since there appears to be no good way to get root path in\n  // Windows, assume that if current dir has no parent dir, we're in\n  // root.\n  var dirname = path.dirname(configPath);\n  var parentDirname = path.dirname(dirname);\n  if (dirname === HOME || dirname === parentDirname) return null;\n\n  // If there is no config in this directory, go one level up and look for\n  // a config there:\n  configPath = path.join(parentDirname, '.csscomb.json');\n  return CSScomb.getCustomConfigPath(configPath);\n};\n\n/**\n * Converts CSS string to AST.\n *\n * @param {String} text CSS string\n * @param {String} [syntax] Syntax name (e.g., `scss`)\n * @param {String} [filename]\n * @returns {Array} AST\n */\nfunction cssToAST(text, syntax, filename) {\n  var string = JSON.stringify;\n  var fileInfo = filename ? ' at ' + filename : '';\n  var tree;\n\n  try {\n    tree = gonzales.parse(text, { syntax: syntax });\n  } catch (e) {\n    throw new Error('Parsing error' + fileInfo + ': ' + e.message);\n  }\n\n  // TODO: When can tree be undefined? <tg>\n  if (typeof tree === 'undefined') {\n    let message = `Undefined tree ${fileInfo}: ${string(text)} =>\n                  ${string(tree)}`;\n    throw new Error(format(message));\n  }\n\n  return tree;\n}\n\n/**\n * Processes tree and detects options.\n *\n * @param {Array} tree\n * @param {Array} handlers List of options that we should look for\n * @returns {Object} Map with detected options and all variants of possible\n * values\n */\nfunction detectInTree(tree, handlers) {\n  var detectedOptions = {};\n  // We walk across complete tree for each handler,\n  // because we need strictly maintain order in which handlers work,\n  // despite fact that handlers work on different level of the tree.\n  handlers.forEach(function (handler) {\n    detectedOptions[handler.name] = handler.detect(tree);\n  });\n  return detectedOptions;\n}\n\n/**\n * Gets the detected options.\n *\n * @param {Object} detected\n * @param {Array} handlers\n * @returns {Object}\n */\nfunction getDetectedOptions(detected, handlers) {\n  var options = {};\n  Object.keys(detected).forEach(function (option) {\n    // List of all the detected variants from the stylesheet\n    // for the given option:\n    var values = detected[option];\n    var i;\n    if (!values.length) {\n      // If there are no values for the option, check if there is\n      // a default one:\n      for (i = handlers.length; i--;) {\n        if (handlers[i].name === option && handlers[i].detectDefault !== undefined) {\n          options[option] = handlers[i].detectDefault;\n          break;\n        }\n      }\n    } else if (values.length === 1) {\n      options[option] = values[0];\n    } else {\n      // If there are more than one value for the option, find\n      // the most popular one; `variants` would be populated\n      // with the popularity for different values.\n      var variants = {};\n      var bestGuess = null;\n      var maximum = 0;\n      for (i = values.length; i--;) {\n        var currentValue = values[i];\n        // Count the current value:\n        if (variants[currentValue]) {\n          variants[currentValue]++;\n        } else {\n          variants[currentValue] = 1;\n        }\n        // If the current variant is the most popular one, treat\n        // it as the best guess:\n        if (variants[currentValue] >= maximum) {\n          maximum = variants[currentValue];\n          bestGuess = currentValue;\n        }\n      }\n      if (bestGuess !== null) {\n        options[option] = bestGuess;\n      }\n    }\n  });\n\n  return options;\n}\n\n/**\n * Gets option's data needed for detection\n *\n * @param {String} optionName\n * @returns {Object} Object with option's name, link to `detect()` method\n * and default value for the case when nothing can be detected\n */\nfunction getHandler(optionName) {\n  var option = require('./options/' + optionName);\n  if (!option.detect) throw new Error('Option does not have `detect()` method.');\n\n  return {\n    name: option.name,\n    detect: option.detect,\n    detectDefault: option.detectDefault\n  };\n}\n\nmodule.exports = CSScomb;","/home/travis/build/npmtest/node-npmtest-csscomb/node_modules/csscomb/lib/core.js":"'use strict';\n\nrequire('babel-polyfill');\n\nlet fs = require('fs');\nlet gonzales = require('gonzales-pe');\nlet minimatch = require('minimatch');\nlet Errors = require('./errors');\nlet Plugin = require('./plugin');\n\nlet vow = require('vow');\nlet vfs = require('vow-fs');\n\nclass Comb {\n  constructor() {\n    this.config = {};\n    this.exclude = [];\n    // Whether lint mode is on.\n    this.lint = false;\n    // List of file paths that should be excluded from processing.\n    this.pathsToExclude = null;\n    // List of used plugins.\n    this.plugins = [];\n    this.pluginsDependencies = {};\n    // List of supported syntaxes.\n    this.supportedSyntaxes = new Set();\n    // Mapping file extensions to syntax\n    this.syntaxMap = new Map();\n    // Whether verbose mode is on.\n    this.verbose = false;\n  }\n\n  /**\n   * Loads configuration from JSON.\n   *\n   * @param {!Object} config\n   * @return {!Comb}\n   */\n  configure(config) {\n    if (typeof config !== 'object')\n      // TODO: throw error\n      throw new Error();\n\n    this.lint = config.lint;\n    this.verbose = config.verbose;\n    if (config.exclude) this.exclude = config.exclude.map(function (pattern) {\n      return new minimatch.Minimatch(pattern);\n    });\n\n    if (config.syntax) {\n      for (let key in config.syntax) {\n        this.syntaxMap.set(key, config.syntax[key]);\n      }\n    }\n\n    for (let i = 0, l = this.plugins.length; i < l; i++) {\n      let plugin = this.plugins[i];\n      let name = plugin.name;\n      if (!config.hasOwnProperty(name)) continue;\n\n      try {\n        plugin.value = config[name];\n        this.config[name] = plugin.value;\n      } catch (e) {\n        // TODO: throw error\n      }\n    }\n\n    // Chaining.\n    return this;\n  }\n\n  /**\n   * Lints all files in a directory.\n   *\n   * @param {String} path\n   * @returns {Promise}\n   */\n  lintDirectory(path) {\n    let files = this._getAcceptableFilesFromDirectory(path);\n    let promises = files.map(file => this.lintFile(file));\n    return Promise.all(promises);\n  }\n\n  /**\n   * Lints a single file.\n   *\n   * @param {String} path\n   * @returns {Promise}\n   */\n  lintFile(path) {\n    let syntax = this._extractSyntax(path);\n    return this._readFile(path).then(string => {\n      return this.lintString(string, { syntax: syntax, filename: path });\n    });\n  }\n\n  /**\n   * Lints a file or a directory.\n   *\n   * @param {String} path\n   */\n  lintPath(path) {\n    path = path.replace(/\\/$/, '');\n    return fs.statSync(path).isDirectory() ? this.lintDirectory(path) : this.lintFile(path);\n  }\n\n  /**\n   * Lints a string.\n   *\n   * @param {String} text\n   * @param {{context: String, filename: String, syntax: String}} options\n   * @returns {Promise} Resolves with <Array> list of found errors.\n   */\n  lintString(text, options) {\n    return this._parseString(text, options).then(this._lintTree.bind(this)).then(errors => {\n      errors.forEach(error => {\n        error.context = this._getContext(text, error.line);\n      });\n\n      return errors;\n    });\n  }\n\n  _getContext(text, currentLineNumber) {\n    var LINES_AROUND = 2;\n    var result = [];\n    var start = currentLineNumber - 1 - LINES_AROUND;\n    var end = currentLineNumber + LINES_AROUND;\n    var lines = text.split(/\\r\\n|\\r|\\n/);\n\n    for (var i = start; i < end; i++) {\n      var line = lines[i];\n      if (!line) continue;\n      var ln = i + 1;\n      if (ln === currentLineNumber) {\n        result.push(ln + '*| ' + line);\n      } else {\n        result.push(ln + ' | ' + line);\n      }\n    }\n    return result.join('\\n');\n  }\n\n  /**\n   * Processes directory recursively.\n   *\n   * @param {String} path\n   * @returns {Promise}\n   */\n  processDirectory(path) {\n    let that = this;\n\n    return vfs.listDir(path).then(function (filenames) {\n      return vow.all(filenames.map(function (filename) {\n        let fullname = path + '/' + filename;\n        return vfs.stat(fullname).then(function (stat) {\n          if (stat.isDirectory() && that._shouldProcess(fullname)) {\n            return that.processDirectory(fullname);\n          } else {\n            return that.processFile(fullname);\n          }\n        });\n      })).then(function (results) {\n        return [].concat.apply([], results);\n      });\n    });\n  }\n\n  /**\n   * Processes single file.\n   *\n   * @param {String} path\n   * @returns {Promise}\n   */\n  processFile(path) {\n    let that = this;\n\n    if (!this._shouldProcessFile(path)) return;\n\n    return new Promise(resolve => {\n      vfs.read(path, 'utf8').then(function (data) {\n        let syntax = that._extractSyntax(path);\n        that.processString(data, {\n          syntax: syntax,\n          filename: path\n        }).then(function (processedData) {\n          if (data === processedData) {\n            if (that.verbose) console.log(' ', path);\n            resolve(0);\n            return;\n          }\n\n          let tick = that.lint ? '!' : '✓';\n          if (that.lint) {\n            if (that.verbose) console.log(tick, path);\n            resolve(1);\n          } else {\n            return vfs.write(path, processedData, 'utf8').then(function () {\n              if (that.verbose) console.log(tick, path);\n              resolve(1);\n            });\n          }\n        });\n      });\n    });\n  }\n\n  /**\n   * Processes directory or file.\n   *\n   * @returns {Promise}\n   */\n  processPath(path) {\n    let that = this;\n    path = path.replace(/\\/$/, '');\n\n    return vfs.stat(path).then(function (stat) {\n      if (stat.isDirectory()) {\n        return that.processDirectory(path);\n      } else {\n        return that.processFile(path);\n      }\n    });\n  }\n\n  /**\n   * Processes a string.\n   *\n   * @param {String} text\n   * @param {{context: String, filename: String, syntax: String}} options\n   * @returns {Promise<string>} Resolves in processed string\n   */\n  processString(text, options) {\n    return this._parseString(text, options).then(this._processTree.bind(this)).then(ast => ast.toString());\n  }\n\n  /**\n   * Add a plugin.\n   * @param {Object} options\n   * @return {Comb}\n   */\n  use(options) {\n    // Check whether plugin with the same is already used.\n    let pluginName = options.name;\n    if (this._pluginAlreadyUsed(pluginName)) {\n      if (this.verbose) console.warn(Errors.twoPluginsWithSameName(pluginName));\n      return;\n    }\n\n    let plugin = new Plugin(options);\n\n    plugin.syntax.forEach(function (s) {\n      this.supportedSyntaxes.add(s);\n    }, this);\n\n    // Sort plugins.\n    let pluginToRunBefore = plugin.runBefore;\n\n    if (!pluginToRunBefore) {\n      this.plugins.push(plugin);\n    } else {\n      if (this._pluginAlreadyUsed(pluginToRunBefore)) {\n        let i = this._pluginIndex(pluginToRunBefore);\n        this.plugins.splice(i, 0, plugin);\n      } else {\n        this.plugins.push(plugin);\n        if (!this.pluginsDependencies[pluginToRunBefore]) this.pluginsDependencies[pluginToRunBefore] = [];\n        this.pluginsDependencies[pluginToRunBefore].push(pluginName);\n      }\n    }\n\n    let dependents = this.pluginsDependencies[pluginName];\n    if (!dependents) return this;\n\n    for (let i = 0, l = dependents.length; i < l; i++) {\n      let name = dependents[i];\n      let x = this._pluginIndex(name);\n      let plugin = this.plugins[x];\n      this.plugins.splice(x, 1);\n      this.plugins.splice(-1, 0, plugin);\n    }\n\n    // Chaining.\n    return this;\n  }\n\n  _getAcceptableFilesFromDirectory(path) {\n    if (!this._shouldProcess(path)) return;\n\n    let files = [];\n    let filesInThisDir = fs.readdirSync(path);\n\n    for (let i = 0, fl = filesInThisDir.length; i < fl; i++) {\n      let fullname = path + '/' + filesInThisDir[i];\n      let stat = fs.statSync(fullname);\n      if (stat.isDirectory() && this._shouldProcess(fullname)) files = files.concat(this._getAcceptableFilesFromDirectory(fullname));else if (this._shouldProcessFile(fullname)) files.push(fullname);\n    }\n\n    return files;\n  }\n\n  /**\n   * @param {Node} ast\n   * @param {String=} filename\n   * @return {Array} List of errors.\n   */\n  _lintTree(ast, filename) {\n    let errors = [];\n    let config = this.config;\n\n    this.plugins.filter(function (plugin) {\n      return typeof plugin.value !== null && typeof plugin.lint === 'function' && plugin.syntax.indexOf(ast.syntax) !== -1;\n    }).forEach(function (plugin) {\n      let e = plugin.lint(ast, config);\n      errors = errors.concat(e);\n    });\n\n    if (filename) {\n      errors.map(function (error) {\n        error.filename = filename;\n        return error;\n      });\n    }\n\n    return errors;\n  }\n\n  _parseString(text, options) {\n    let syntax = options && options.syntax;\n    let filename = options && options.filename || '';\n    let context = options && options.context;\n    let tree;\n\n    if (!text) return this.lint ? [] : text;\n\n    if (!syntax) syntax = 'css';\n    this.syntax = syntax;\n\n    return new Promise(function (resolve) {\n      try {\n        tree = gonzales.parse(text, { syntax: syntax, rule: context });\n        resolve(tree, filename);\n      } catch (e) {\n        let version = require('../package.json').version;\n        let message = filename ? [filename] : [];\n        message.push(e.message);\n        message.push('CSScomb Core version: ' + version);\n        e.stack = e.message = message.join('\\n');\n        throw e;\n      }\n    });\n  }\n\n  _pluginAlreadyUsed(name) {\n    return this._pluginIndex(name) !== -1;\n  }\n\n  _pluginIndex(name) {\n    let index = -1;\n    this.plugins.some(function (plugin, i) {\n      if (plugin.name === name) {\n        index = i;\n        return true;\n      }\n    });\n    return index;\n  }\n\n  /**\n   * @param {Node} ast\n   * @return {Node} Transformed AST\n   */\n  _processTree(ast) {\n    let config = this.config;\n\n    this.plugins.filter(function (plugin) {\n      return plugin.value !== null && typeof plugin.process === 'function' && plugin.syntax.indexOf(ast.syntax) !== -1;\n    }).forEach(function (plugin) {\n      plugin.process(ast, config);\n    });\n\n    return ast;\n  }\n\n  _readFile(path) {\n    return new Promise((resolve, reject) => {\n      if (!this._shouldProcessFile(path)) reject();\n\n      fs.readFile(path, 'utf8', function (e, string) {\n        if (e) reject();\n        resolve(string);\n      });\n    });\n  }\n\n  /**\n   * Checks if path is not present in `exclude` list.\n   *\n   * @param {String} path\n   * @returns {Boolean} False if specified path is present in `exclude` list.\n   * Otherwise returns true.\n   */\n  _shouldProcess(path) {\n    path = path.replace(/\\/$/, '');\n    if (!fs.existsSync(path)) {\n      console.warn('Path ' + path + ' was not found.');\n      return false;\n    }\n\n    path = path.replace(/^\\.\\//, '');\n    return this.exclude.every(function (e) {\n      return !e.match(path);\n    });\n  }\n\n  /**\n   * Checks if specified path is not present in `exclude` list and it has one of\n   * acceptable syntaxes.\n   *\n   * @param {String} path\n   * @returns {Boolean} False if the path either has unacceptable extension or\n   * is present in `exclude` list. True if everything is ok.\n   */\n  _shouldProcessFile(path) {\n    // Get file's extension:\n    var syntax = this._extractSyntax(path);\n\n    // Check if syntax is supported. If not, ignore the file:\n    if (!this.supportedSyntaxes.has(syntax)) return false;\n\n    return this._shouldProcess(path);\n  }\n\n  /**\n   * Extract syntax by file path\n   *\n   * @param {String} path\n   * @returns {String} syntax\n   */\n  _extractSyntax(path) {\n    var extension = path.split('.').pop();\n\n    return this.syntaxMap.get('.' + extension) || extension;\n  }\n}\n\nmodule.exports = Comb;","/home/travis/build/npmtest/node-npmtest-csscomb/node_modules/csscomb/lib/errors.js":"'use strict';\n\nlet format = require('./format');\n\nmodule.exports = {\n  configParsingError(configPath) {\n    return `Error parsing configuration file ${configPath}.`;\n  },\n\n  implementSetValue(valueType) {\n    if (typeof valueType === 'undefined') throw new Error();\n\n    return format(`If you see this message and you are not\n        a developer adding a new option, please open an issue here:\n        https://github.com/csscomb/core/issues/new\\n\n        For option to accept values of type \"${valueType}\"\n        you need to implement custom \\`setValue()\\` method.`);\n  },\n\n  missingName() {\n    return 'Plugin must have a valid \\`name\\` property.';\n  },\n\n  missingSetValue() {\n    return format(`Plugin must either implemet \\`setValue()\\` method\n        or provide \\`accepts\\` object with acceptable values.`);\n  },\n\n  missingSyntax() {\n    return 'Plugin must list supported syntaxes.';\n  },\n\n  missingTemplateFile(file) {\n    return format(`Template configuration file ${file}\n                   was not found.`);\n  },\n\n  twoPluginsWithSameName(pluginName) {\n    if (typeof pluginName === 'undefined') throw new Error();\n\n    return format(`You're trying to use one plugin twice:\n        ${pluginName}. Please make sure there are not two different\n        plugins with the same name.`);\n  },\n\n  unacceptableBoolean(pattern) {\n    if (typeof pattern === 'undefined') throw new Error();\n\n    return `Value must be one of the following: ${pattern.join(', ')}.`;\n  },\n\n  unacceptableNumber() {\n    return 'Value must be an integer.';\n  },\n\n  unacceptableString(pattern) {\n    if (typeof pattern === 'undefined') throw new Error();\n\n    return `Value must match pattern ${pattern}.`;\n  },\n\n  unacceptableValueType(valueType, accepts) {\n    if (typeof valueType === 'undefined' || typeof accepts === 'undefined') throw new Error();\n\n    return format(`The option does not accept values of type\n        ${valueType}.\\nValue\\'s type must be one the following:\n        ${Object.keys(accepts).join(', ')}.`);\n  }\n};","/home/travis/build/npmtest/node-npmtest-csscomb/node_modules/csscomb/lib/format.js":"'use strict';\n\nmodule.exports = function (string) {\n  return string.replace(/\\n\\s+/gm, ' ');\n};","/home/travis/build/npmtest/node-npmtest-csscomb/node_modules/csscomb/lib/plugin.js":"'use strict';\n\nlet Errors = require('./errors');\n\nlet Plugin = function (methods) {\n  for (let method in methods) {\n    this[method] = typeof method === 'function' ? methods[method].bind(this) : methods[method];\n  }\n\n  this.validate();\n};\n\nPlugin.prototype = {\n  /**\n   * Plugin's name.\n   * @type {String}\n   */\n  name: null,\n\n  /**\n   * List of supported syntaxes.\n   * @type {Array}\n   */\n  syntax: null,\n\n  /**\n   * @type {Object}\n   */\n  accepts: null,\n\n  /**\n   * @type {Function}\n   */\n  process: null,\n\n  /**\n   * @type {Function}\n   */\n  lint: null,\n\n  value_: null,\n  get value() {\n    return this.value_;\n  },\n  set value(value) {\n    let valueType = typeof value;\n    let pattern = this.accepts && this.accepts[valueType];\n\n    if (this.setValue) {\n      this.value_ = this.setValue(value);\n      return this.value_;\n    }\n\n    if (!pattern) throw new Error(Errors.unacceptableValueType(valueType, this.accepts));\n\n    if (valueType === 'boolean') {\n      if (pattern.indexOf(value) < 0) throw new Error(Errors.unacceptableBoolean(pattern));\n      this.value_ = value;\n      return this.value_;\n    }\n\n    if (valueType === 'number') {\n      if (value !== parseInt(value)) throw new Error(Errors.unacceptableNumber());\n      this.value_ = new Array(value + 1).join(' ');\n      return this.value_;\n    }\n\n    if (valueType = 'string') {\n      if (!value.match(pattern)) throw new Error(Errors.unacceptableString(pattern));\n      this.value_ = value;\n      return this.value_;\n    }\n\n    throw new Error(Errors.implementSetValue(valueType));\n  },\n\n  validate() {\n    if (typeof this.name !== 'string' || !this.name) throw new Error(Errors.missingName());\n\n    if (!Array.isArray(this.syntax) || this.syntax.length === 0) throw new Error(Errors.missingSyntax());\n\n    if (typeof this.accepts !== 'object' && typeof this.setValue !== 'function') throw new Error(Errors.missingSetValue());\n  }\n};\n\nmodule.exports = Plugin;","/home/travis/build/npmtest/node-npmtest-csscomb/node_modules/csscomb/lib/cli.js":"'use strict';\n\n/**\n * Command line implementation for CSSComb\n *\n * Usage example:\n * ./node_modules/.bin/csscomb [options] [file1 [dir1 [fileN [dirN]]]]\n */\n\nvar fs = require('fs');\nvar parseArgs = require('minimist');\nvar path = require('path');\n\nvar Comb = require('./csscomb');\nvar Errors = require('./errors');\n\nvar getInputData = new Promise(function (resolve) {\n  var input = '';\n  process.stdin.resume();\n  process.stdin.setEncoding('utf8');\n  process.stdin.on('data', function (data) {\n    input += data;\n  });\n  process.stdin.on('end', function () {\n    resolve(input);\n  });\n});\n\nvar comb = new Comb();\nvar options = getOptions();\n\nif (options.help) {\n  displayHelp();\n  process.exit(0);\n}\n\nif (options.detect) {\n  const config = detectConfig();\n  process.stdout.write(config);\n  process.exit(0);\n}\n\nvar config = getConfig();\ncomb.configure(config);\n\nif (process.stdin.isTTY) {\n  processFiles(options._);\n} else {\n  processSTDIN();\n}\n\nfunction getOptions() {\n  var parserOptions = {\n    boolean: ['help', 'lint', 'verbose'],\n    alias: {\n      config: 'c',\n      detect: 'd',\n      lint: 'l',\n      help: 'h',\n      verbose: 'v'\n    }\n  };\n  return parseArgs(process.argv.slice(2), parserOptions);\n}\n\nfunction displayHelp() {\n  var help = ['NAME', '    csscomb — Lint and fix style errors in css files', '', 'SYNOPSIS', '    csscomb [options] file.css', '    cat file.css | csscomb [options] -', '', 'OPTIONS', '    -c, --config [path]', '        Path to configuration file.', '    -d, --detect', '        Run the tool in detect mode, returning detected options.', '    -l, --lint', '        Run the tool in linter mode, without modifying files.', '    -h, --help', '        Display help message.', '    -v, --verbose', '        Whether to print logging info.'];\n  process.stdout.write(help.join('\\n'));\n}\n\nfunction detectConfig() {\n  const config = Comb.detectInFile(options.detect);\n  return JSON.stringify(config, false, 4);\n}\n\nfunction getConfig() {\n  var configPath = options.config && path.resolve(process.cwd(), options.config) || Comb.getCustomConfigPath();\n\n  var config;\n  if (!fs.existsSync(configPath)) {\n    config = require('../config/csscomb.json');\n  } else if (configPath.match(/\\.css$/)) {\n    config = Comb.detectInFile(configPath);\n  } else {\n    config = Comb.getCustomConfig(configPath);\n  }\n\n  if (!config) {\n    const errorMessage = Errors.configParsingError(configPath);\n    process.stderr.write(errorMessage);\n    process.exit(1);\n  }\n\n  applyTemplate(config);\n  if (options.verbose) config.verbose = options.verbose;\n  if (options.lint) config.lint = options.lint;\n\n  return config;\n}\n\nfunction applyTemplate(config) {\n  if (!config.template) return;\n\n  if (!fs.existsSync(config.template)) {\n    const errorMessage = Errors.missingTemplateFile(config.template);\n    process.stderr.write(errorMessage);\n    process.exit(1);\n  }\n\n  var templateConfig = Comb.detectInFile(config.template);\n  for (var attrname in templateConfig) {\n    if (templateConfig.hasOwnProperty(attrname) && !config[attrname]) {\n      config[attrname] = templateConfig[attrname];\n    }\n  }\n}\n\nfunction processFiles(files) {\n  const promises = files.map(file => {\n    return comb.processPath(file);\n  });\n\n  Promise.all(promises).catch(error => {\n    process.stderr.write(error.stack);\n    process.exit(1);\n  }).then(c => {\n    var tbchanged = c.filter(isChanged => {\n      return isChanged !== undefined;\n    }).reduce((a, b) => {\n      return a + b;\n    }, 0);\n\n    var changed = options.lint ? 0 : tbchanged;\n\n    if (options.verbose) {\n      let message = [`${c.length} file${c.length === 1 ? '' : 's'} processed`, `${changed} file${changed === 1 ? '' : 's'} fixed`, ''].join('\\n');\n      process.stdout.write(message);\n    }\n\n    if (options.lint && tbchanged) {\n      process.exit(1);\n    }\n\n    process.exit(0);\n  });\n}\n\nfunction processSTDIN() {\n  getInputData.then(processInputData);\n}\n\nfunction processInputData(input) {\n  comb.processString(input).catch(e => {\n    process.stderr.write(e.message);\n    process.exit(1);\n  }).then(output => {\n    process.stdout.write(output);\n    process.exit(0);\n  });\n}","/home/travis/build/npmtest/node-npmtest-csscomb/node_modules/csscomb/lib/options/always-semicolon.js":"'use strict';\n\nvar gonzales = require('gonzales-pe');\n\nlet option = {\n  /**\n   * Option's name as it's used in config.\n   * @type {String}\n   */\n  get name() {\n    return 'always-semicolon';\n  },\n\n  /**\n   * List of syntaxes that are supported by this option.\n   * @type {Array}\n   */\n  get syntax() {\n    return ['css', 'less', 'sass', 'scss'];\n  },\n\n  /**\n   * Types of values this option accepts in config.\n   * @type {Object}\n   */\n  get accepts() {\n    return {\n      boolean: [true]\n    };\n  },\n\n  /**\n   * Checks ast for code style errors.\n   *\n   * @param {Node} ast\n   * @return {Array?} List of found errors.\n   */\n  lint(ast) {\n    var errors = [];\n\n    ast.traverseByType('block', block => {\n      block.eachFor(currentNode => {\n        var nodeWithoutSemicolon;\n        // Skip nodes that already have `;` at the end:\n        if (currentNode.is('declarationDelimiter')) return null;\n\n        // Add semicolon only after declarations and includes.\n        // If current node is include, insert semicolon right into it.\n        // If it's declaration, look for value node:\n        if (currentNode.is('include') || currentNode.is('extend')) {\n          nodeWithoutSemicolon = currentNode;\n        } else if (currentNode.is('declaration')) {\n          nodeWithoutSemicolon = currentNode.last('value');\n        } else {\n          return;\n        }\n\n        errors.push({\n          message: 'Missing semicolon',\n          line: nodeWithoutSemicolon.end.line,\n          column: nodeWithoutSemicolon.end.column + 1\n        });\n\n        // Stop looping through block's children:\n        return null;\n      });\n    });\n\n    return errors;\n  },\n\n  /**\n   * Processes ast and fixes found code style errors.\n   * @param {Node} ast\n   */\n  process(ast) {\n    var nodeWithoutSemicolon;\n\n    ast.traverseByType('block', block => {\n      block.eachFor(currentNode => {\n        // Skip nodes that already have `;` at the end:\n        if (currentNode.is('declarationDelimiter')) return null;\n\n        // Add semicolon only after declarations and includes.\n        // If current node is include, insert semicolon right into it.\n        // If it's declaration, look for value node:\n        if (currentNode.is('include') || currentNode.is('extend')) {\n          nodeWithoutSemicolon = currentNode;\n        } else if (currentNode.is('declaration')) {\n          nodeWithoutSemicolon = currentNode.last('value');\n        } else {\n          return;\n        }\n\n        // Check if there are spaces and comments at the end of the node\n        for (var j = nodeWithoutSemicolon.length; j--;) {\n          var lastNode = nodeWithoutSemicolon.get(j);\n\n          // If the node's last child is block, do not add semicolon:\n          // TODO: Add syntax check and run the code only for scss\n          if (lastNode.is('block')) {\n            return null;\n          } else if (!lastNode.is('space') && !lastNode.is('multilineComment') && !lastNode.is('singlelineComment')) {\n            j++;\n            break;\n          }\n        }\n\n        var declDelim = gonzales.createNode({\n          type: 'declarationDelimiter',\n          content: ';'\n        });\n        nodeWithoutSemicolon.insert(j, declDelim);\n        return null;\n      });\n    });\n  },\n\n  /**\n   * Detects the value of this option in ast.\n   * @param {Node} ast\n   * @return {Array?} List of detected values\n   */\n  detect(ast) {\n    var detected = [];\n\n    ast.traverseByType('block', block => {\n      block.eachFor(node => {\n        if (node.is('declarationDelimiter')) {\n          detected.push(true);\n          return null;\n        } else if (node.is('declaration')) {\n          detected.push(false);\n          return null;\n        }\n      });\n    });\n\n    return detected;\n  }\n};\n\nmodule.exports = option;","/home/travis/build/npmtest/node-npmtest-csscomb/node_modules/csscomb/lib/options/block-indent.js":"'use strict';\n\nlet option = {\n  /**\n   * Option's name as it's used in config.\n   * @type {String}\n   */\n  get name() {\n    return 'block-indent';\n  },\n\n  /**\n   * Name of option that must run after this option.\n   * @type {String}\n   */\n  get runBefore() {\n    return 'sort-order';\n  },\n\n  /**\n   * List of syntaxes that are supported by this option.\n   * @type {Array}\n   */\n  get syntax() {\n    return ['css', 'less', 'sass', 'scss'];\n  },\n\n  /**\n   * Types of values this option accepts in config.\n   * @type {Object}\n   */\n  get accepts() {\n    return {\n      number: true,\n      string: /^[ \\t]*$/\n    };\n  },\n\n  /**\n   * Processes ast and fixes found code style errors.\n   * @param {Node} ast\n   */\n  process(ast) {\n    ast.eachFor('space', function (whitespaceNode, i) {\n      var spaces = whitespaceNode.content.replace(/\\n[ \\t]+/gm, '\\n');\n\n      if (spaces === '') {\n        ast.remove(i);\n      } else {\n        whitespaceNode.content = spaces;\n      }\n    });\n\n    this._processNode(ast, 0);\n  },\n\n  /**\n   * Detects the value of this option in ast.\n   * @param {Node} ast\n   * @return {Array} List of detected values\n   */\n  detect(ast) {\n    var detected = [];\n\n    ast.traverse(function (node) {\n      // Continue only with non-empty {...} blocks:\n      if (!node.is('atrulers') && !node.is('block') || !node.length) return;\n\n      node.eachFor('space', function (whitespaceNode) {\n        var spaces = whitespaceNode.content;\n        var lastIndex = spaces.lastIndexOf('\\n');\n\n        // Do not continue if there is no line break:\n        if (lastIndex < 0) return;\n\n        // Number of spaces from beginning of line:\n        var spacesLength = spaces.slice(lastIndex + 1).length + 1;\n        detected.push(new Array(spacesLength).join(' '));\n      });\n    });\n\n    return detected;\n  },\n\n  /**\n   * @param {Node} node\n   * @param {Number} level\n   */\n  _processNode(node, level) {\n    var that = this;\n\n    node.forEach(function (n) {\n      if (node.syntax === 'sass' && n.is('block')) {\n        that._processSassBlock(n, level);\n      }\n\n      // Continue only with space nodes inside {...}:\n      if (node.syntax !== 'sass' && level !== 0 && n.is('space')) {\n        that._processSpaceNode(n, level);\n      }\n\n      if (n.is('block') || n.is('atrulers')) level++;\n\n      that._processNode(n, level);\n    });\n  },\n\n  /**\n   * @param {Node} node\n   * @param {Number} level\n   */\n  _processSassBlock(node, level) {\n    var value = this.value;\n\n    node.eachFor('space', function (whitespaceNode) {\n      if (whitespaceNode.content === '\\n') return;\n\n      var spaces = whitespaceNode.content.replace(/[ \\t]/gm, '');\n      spaces += new Array(level + 2).join(value);\n      whitespaceNode.content = spaces;\n    });\n  },\n\n  /**\n   * @param {Node} node\n   * @param {Number} level\n   */\n  _processSpaceNode(node, level) {\n    var value = this.value;\n\n    // Remove all whitespaces and tabs, leave only new lines:\n    var spaces = node.content.replace(/[ \\t]/gm, '');\n\n    if (!spaces) return;\n\n    spaces += new Array(level + 1).join(value);\n    node.content = spaces;\n  }\n};\n\nmodule.exports = option;","/home/travis/build/npmtest/node-npmtest-csscomb/node_modules/csscomb/lib/options/color-case.js":"'use strict';\n\nlet option = {\n  /**\n   * Option's name as it's used in config.\n   * @type {String}\n   */\n  get name() {\n    return 'color-case';\n  },\n\n  /**\n   * List of syntaxes that are supported by this option.\n   * @type {Array}\n   */\n  get syntax() {\n    return ['css', 'less', 'sass', 'scss'];\n  },\n\n  /**\n   * Types of values this option accepts in config.\n   * @type {Object}\n   */\n  get accepts() {\n    return {\n      string: /^lower|upper$/\n    };\n  },\n\n  /**\n   * Processes ast and fixes found code style errors.\n   * @param {Node} ast\n   */\n  process(ast) {\n    var value = this.value;\n\n    ast.traverseByType('color', function (color) {\n      color.content = value === 'lower' ? color.content.toLowerCase() : color.content.toUpperCase();\n    });\n  },\n\n  /**\n   * Detects the value of this option in ast.\n   * @param {Node} ast\n   * @return {Array} List of detected values\n   */\n  detect(ast) {\n    var detected = [];\n\n    ast.traverseByType('color', function (color) {\n      if (color.content.match(/^[^A-F]*[a-f][^A-F]*$/)) {\n        detected.push('lower');\n      } else if (color.content.match(/^[^a-f]*[A-F][^a-f]*$/)) {\n        detected.push('upper');\n      }\n    });\n\n    return detected;\n  }\n};\n\nmodule.exports = option;","/home/travis/build/npmtest/node-npmtest-csscomb/node_modules/csscomb/lib/options/color-shorthand.js":"'use strict';\n\nlet option = {\n  /**\n   * Option's name as it's used in config.\n   * @type {String}\n   */\n  get name() {\n    return 'color-shorthand';\n  },\n\n  /**\n   * List of syntaxes that are supported by this option.\n   * @type {Array}\n   */\n  get syntax() {\n    return ['css', 'less', 'sass', 'scss'];\n  },\n\n  /**\n   * Types of values this option accepts in config.\n   * @type {Object}\n   */\n  get accepts() {\n    return {\n      boolean: [true, false]\n    };\n  },\n\n  /**\n   * Processes ast and fixes found code style errors.\n   * @param {Node} ast\n   */\n  process(ast) {\n    var value = this.value;\n\n    ast.traverseByType('color', function (color) {\n      color.content = value ? color.content.replace(/(\\w)\\1(\\w)\\2(\\w)\\3/i, '$1$2$3') : color.content.replace(/^(\\w)(\\w)(\\w)$/, '$1$1$2$2$3$3');\n    });\n  },\n\n  /**\n   * Detects the value of this option in ast.\n   * @param {Node} ast\n   * @return {Array} List of detected values\n   */\n  detect(ast) {\n    var detected = [];\n\n    ast.traverseByType('color', function (color) {\n      if (color.content.match(/^\\w{3}$/)) {\n        detected.push(true);\n      } else if (color.content.match(/^(\\w)\\1(\\w)\\2(\\w)\\3$/)) {\n        detected.push(false);\n      }\n    });\n\n    return detected;\n  }\n};\n\nmodule.exports = option;","/home/travis/build/npmtest/node-npmtest-csscomb/node_modules/csscomb/lib/options/element-case.js":"'use strict';\n\nlet option = {\n  /**\n   * Option's name as it's used in config.\n   * @type {String}\n   */\n  get name() {\n    return 'element-case';\n  },\n\n  /**\n   * List of syntaxes that are supported by this option.\n   * @type {Array}\n   */\n  get syntax() {\n    return ['css', 'less', 'sass', 'scss'];\n  },\n\n  /**\n   * Types of values this option accepts in config.\n   * @type {Object}\n   */\n  get accepts() {\n    return {\n      string: /^lower|upper$/\n    };\n  },\n\n  /**\n   * Processes ast and fixes found code style errors.\n   * @param {Node} ast\n   */\n  process(ast) {\n    let value = this.value;\n\n    ast.traverse(node => {\n      if (!node.is('selector') && !node.is('arguments')) return;\n\n      node.forEach('typeSelector', selector => {\n        selector.forEach('ident', ident => {\n          ident.content = value === 'lower' ? ident.content.toLowerCase() : ident.content.toUpperCase();\n        });\n      });\n    });\n  },\n\n  /**\n   * Detects the value of this option in ast.\n   * @param {Node} ast\n   * @return {Array} List of detected values\n   */\n  detect(ast) {\n    let detected = [];\n\n    ast.traverse(node => {\n      if (!node.is('selector') && !node.is('arguments')) return;\n\n      node.forEach('typeSelector', selector => {\n        selector.forEach('ident', ident => {\n          if (ident.content.match(/^[a-z]+$/)) {\n            detected.push('lower');\n          } else if (ident.content.match(/^[A-Z]+$/)) {\n            detected.push('upper');\n          }\n        });\n      });\n    });\n\n    return detected;\n  }\n};\n\nmodule.exports = option;","/home/travis/build/npmtest/node-npmtest-csscomb/node_modules/csscomb/lib/options/eof-newline.js":"'use strict';\n\nlet gonzales = require('gonzales-pe');\n\nlet option = {\n  /**\n   * Option's name as it's used in config.\n   * @type {String}\n   */\n  get name() {\n    return 'eof-newline';\n  },\n\n  /**\n   * List of syntaxes that are supported by this option.\n   * @type {Array}\n   */\n  get syntax() {\n    return ['css', 'less', 'sass', 'scss'];\n  },\n\n  /**\n   * Types of values this option accepts in config.\n   * @type {Object}\n   */\n  get accepts() {\n    return {\n      boolean: [true, false]\n    };\n  },\n\n  /**\n   * Processes ast and fixes found code style errors.\n   * @param {Node} ast\n   */\n  process(ast) {\n    var lastChild = ast.last();\n\n    if (!lastChild.is('space')) {\n      lastChild = gonzales.createNode({ type: 'space', content: '' });\n      ast.content.push(lastChild);\n    }\n\n    lastChild.content = lastChild.content.replace(/\\n$/, '');\n    if (this.value) lastChild.content += '\\n';\n  },\n\n  /**\n   * Detects the value of this option in ast.\n   * @param {Node} ast\n   * @return {Array} List of detected values\n   */\n  detect(ast) {\n    var lastChild = ast.last();\n\n    if (lastChild.is('space') && lastChild.content.indexOf('\\n') !== -1) {\n      return [true];\n    } else {\n      return [false];\n    }\n  }\n};\n\nmodule.exports = option;","/home/travis/build/npmtest/node-npmtest-csscomb/node_modules/csscomb/lib/options/leading-zero.js":"'use strict';\n\nmodule.exports = {\n  name: 'leading-zero',\n\n  syntax: ['css', 'less', 'sass', 'scss'],\n\n  accepts: {\n    boolean: [true, false]\n  },\n\n  /**\n   * Processes tree node.\n   * @param {node} ast\n   */\n  process: function (ast) {\n    let value = this.value;\n\n    ast.traverseByType('number', function (number) {\n      if (!value) {\n        number.content = number.content.replace(/^0+(?=\\.)/, '');\n      } else if (number.content[0] === '.') {\n        number.content = '0' + number.content;\n      }\n    });\n  },\n\n  /**\n   * Detects the value of an option at the tree node.\n   *\n   * @param {node} ast\n   */\n  detect: function (ast) {\n    let detected = [];\n\n    ast.traverseByType('number', function (number) {\n      if (number.content.match(/^\\.[0-9]+/)) {\n        detected.push(false);\n      } else if (number.content.match(/^0\\.[0-9]+/)) {\n        detected.push(true);\n      }\n    });\n\n    return detected;\n  }\n};","/home/travis/build/npmtest/node-npmtest-csscomb/node_modules/csscomb/lib/options/lines-between-rulesets.js":"'use strict';\n\nlet gonzales = require('gonzales-pe');\n\nlet option = {\n  newLinesString: '',\n  newLinesNode: null,\n\n  /**\n   * Option's name as it's used in config.\n   * @type {String}\n   */\n  get name() {\n    return 'lines-between-rulesets';\n  },\n\n  /**\n   * Name of option that must run after this option.\n   * @type {String}\n   */\n  get runBefore() {\n    return 'block-indent';\n  },\n\n  /**\n   * List of syntaxes that are supported by this option.\n   * @type {Array}\n   */\n  get syntax() {\n    return ['css', 'less', 'sass', 'scss'];\n  },\n\n  /**\n   * Types of values this option accepts in config.\n   * @type {Object}\n   */\n  get accepts() {\n    return {\n      number: true\n    };\n  },\n\n  /**\n   * @param {number} value\n   * @returns {number}\n   */\n  /*\n  ** Still need to override, as the core implementation of setValue doesn't\n  ** pass numbers through, but creates a string of spaces of the same length.\n  */\n  setValue(value) {\n    let valueType = typeof value;\n\n    if (valueType !== 'number') {\n      throw new Error('Value must be a number.');\n    }\n\n    return value;\n  },\n\n  buildSpacing(syntax) {\n    let spacing = '';\n    let numNewLines = 0;\n    let newLinesOffset = 1;\n\n    if (syntax === 'sass') {\n      newLinesOffset = 0;\n    }\n\n    numNewLines = Math.round(this.value) + newLinesOffset;\n\n    for (var i = 0; i < numNewLines; i++) {\n      spacing += '\\n';\n    }\n\n    return spacing;\n  },\n\n  /**\n   * Processes ast and fixes found code style errors.\n   * @param {Node} ast\n   */\n  process(ast) {\n    this.newLinesString = this.buildSpacing(ast.syntax);\n    this.newLinesNode = gonzales.createNode({\n      type: 'space',\n      content: this.newLinesString\n    });\n    this.processBlock(ast);\n  },\n\n  processBlock(x) {\n    if (x.is('stylesheet')) {\n      // Check all @rules\n      this.processAtRules(x);\n\n      // Check all rulesets\n      this.processRuleSets(x);\n    }\n\n    x.forEach(node => {\n      if (!node.is('block')) {\n        return this.processBlock(node);\n      }\n\n      // Check all @rules\n      this.processAtRules(node);\n\n      // Check all rulesets\n      this.processRuleSets(node);\n\n      this.processBlock(node);\n    });\n  },\n\n  processAtRules(node) {\n    node.forEach('atrule', (atRuleNode, index) => {\n      this.insertNewlines(node, index);\n    });\n  },\n\n  processRuleSets(node) {\n    node.forEach('ruleset', (ruleSetNode, index) => {\n      this.insertNewlines(node, index);\n    });\n  },\n\n  isComment(node) {\n    if (!node) {\n      return false;\n    }\n    return node.is('singlelineComment') || node.is('multilineComment');\n  },\n\n  isNewline(node) {\n    if (!node) {\n      return false;\n    }\n    return node.content === '\\n';\n  },\n\n  prevLineIsComment(parent, index) {\n    let indexThreshold = 2;\n    let prevChild;\n    let prevMinusOneChild;\n    let prevMinusTwoChild;\n    let parentSyntax = parent ? parent.syntax : null;\n\n    // Sass is troublesome because newlines are counted as separate nodes\n    if (parentSyntax === 'sass') {\n      indexThreshold = 3;\n    }\n\n    if (!parent || index < indexThreshold) {\n      return false;\n    }\n\n    prevChild = parent.get(index - 1);\n    prevMinusOneChild = parent.get(index - 2);\n\n    if (parentSyntax === 'sass') {\n      prevMinusTwoChild = parent.get(index - 3);\n      return this.isComment(prevMinusTwoChild) && this.isNewline(prevMinusOneChild) && prevChild.is('space');\n    }\n\n    return this.isComment(prevMinusOneChild) && prevChild.is('space');\n  },\n\n  /*\n  ** Find the latest previous child that isn't a comment, and return its index.\n  */\n  findLatestNonCommentNode(parent, index) {\n    let prevChild;\n    let lastNonCommentIndex = -1;\n    let currentIndex = index;\n    let jumpSize = 2;\n\n    if (parent.syntax === 'sass') {\n      jumpSize = 3;\n    }\n\n    while (currentIndex >= 0) {\n      if (this.prevLineIsComment(parent, currentIndex)) {\n        currentIndex -= jumpSize;\n        continue;\n      }\n\n      prevChild = parent.get(currentIndex - 1);\n\n      if (!this.isComment(prevChild)) {\n        lastNonCommentIndex = currentIndex - 1;\n        break;\n      }\n\n      currentIndex--;\n    }\n\n    return lastNonCommentIndex;\n  },\n\n  insertNewlinesAsString(node) {\n    let content = node.content;\n    let lastNewline = content.lastIndexOf('\\n');\n    let newContent;\n\n    if (lastNewline > -1) {\n      content = content.substring(lastNewline + 1);\n    }\n\n    newContent = this.newLinesString + content;\n    node.content = newContent;\n  },\n\n  insertNewlinesAsNode(node) {\n    node.insert(node.length, this.newLinesNode);\n  },\n\n  insertNewlines(node, index) {\n    let prevChild = node.get(index - 1);\n    let shouldInsert = false;\n\n    // Check for previous nodes that are not a space\n    // Do not insert if the ruleset is the first item\n    for (var i = 0; i < index; i++) {\n      if (!node.get(i).is('space')) {\n        shouldInsert = true;\n        break;\n      }\n    }\n\n    if (prevChild && shouldInsert) {\n      if (this.prevLineIsComment(node, index) || this.isComment(prevChild)) {\n        let lastNonCommentIndex = this.findLatestNonCommentNode(node, index);\n        prevChild = node.get(lastNonCommentIndex);\n      }\n\n      if (prevChild.is('space')) {\n        this.insertNewlinesAsString(prevChild);\n      } else {\n        this.insertNewlinesAsNode(prevChild);\n      }\n    }\n  }\n};\n\nmodule.exports = option;","/home/travis/build/npmtest/node-npmtest-csscomb/node_modules/csscomb/lib/options/quotes.js":"'use strict';\n\nmodule.exports = {\n  name: 'quotes',\n\n  syntax: ['css', 'less', 'sass', 'scss'],\n\n  accepts: {\n    string: /^single|double$/\n  },\n\n  /**\n   * Processes tree node.\n   * @param {node} ast\n   */\n  process: function (ast) {\n    let value = this.value;\n\n    ast.traverseByType('string', function (string) {\n      if (string.content[0] === '\"' && value === 'single') {\n        string.content = string.content\n        // Unescape all escaped double quotes\n        .replace(/\\\\\"/g, '\"')\n        // Escape all the single quotes\n        .replace(/([^\\\\])'/g, '$1\\\\\\'')\n        // Replace the first and the last quote\n        .replace(/^\"|\"$/g, '\\'');\n      } else if (string.content[0] === '\\'' && value === 'double') {\n        string.content = string.content\n        // Unescape all escaped single quotes\n        .replace(/\\\\'/g, '\\'')\n        // Escape all the double quotes\n        .replace(/([^\\\\])\"/g, '$1\\\\\\\"')\n        // Replace the first and the last quote\n        .replace(/^'|'$/g, '\"');\n      }\n    });\n  },\n\n  /**\n   * Detects the value of an option at the tree node.\n   *\n   * @param {node} ast\n   */\n  detect: function (ast) {\n    let detected = [];\n\n    ast.traverseByType('string', function (string) {\n      if (string.content[0] === '\"') {\n        detected.push('double');\n      } else if (string.content[0] === '\\'') {\n        detected.push('single');\n      }\n    });\n\n    return detected;\n  }\n};","/home/travis/build/npmtest/node-npmtest-csscomb/node_modules/csscomb/lib/options/remove-empty-rulesets.js":"'use strict';\n\nmodule.exports = function () {\n  function processNode(node) {\n    removeEmptyRulesets(node);\n    mergeAdjacentWhitespace(node);\n  }\n\n  function removeEmptyRulesets(stylesheet) {\n    stylesheet.forEach('ruleset', function (ruleset, i) {\n      var block = ruleset.first('block');\n      processNode(block);\n      if (isEmptyBlock(block)) stylesheet.removeChild(i);\n    });\n  }\n\n  /**\n   * Removing ruleset nodes from tree may result in two adjacent whitespace\n   * nodes which is not correct AST:\n   * [space, ruleset, space] => [space, space]\n   * To ensure correctness of further processing we should merge such nodes\n   * into one:\n   * [space, space] => [space]\n   */\n  function mergeAdjacentWhitespace(node) {\n    var i = node.content.length - 1;\n    while (i-- > 0) {\n      if (node.get(i).is('space') && node.get(i + 1).is('space')) {\n        node.get(i).content += node.get(i + 1).content;\n        node.removeChild(i + 1);\n      }\n    }\n  }\n\n  /**\n   * Block is considered empty when it has nothing but spaces.\n   */\n  function isEmptyBlock(node) {\n    if (!node.length) return true;\n\n    return !node.content.some(function (node) {\n      return !node.is('space');\n    });\n  }\n\n  return {\n    name: 'remove-empty-rulesets',\n\n    runBefore: 'block-indent',\n\n    syntax: ['css', 'less', 'sass', 'scss'],\n\n    accepts: {\n      boolean: [true]\n    },\n\n    /**\n     * Remove rulesets with no declarations.\n     *\n     * @param {String} ast\n     */\n    process: function (ast) {\n      processNode(ast);\n    },\n\n    detectDefault: true,\n\n    /**\n     * Detects the value of an option at the tree node.\n     * This option is treated as `true` by default, but any trailing space\n     * would invalidate it.\n     *\n     * @param {node} ast\n     */\n    detect: function (ast) {\n      let detected = [];\n\n      ast.traverse(function (node) {\n        if (!node.is('atrulers') && !node.is('block')) return;\n\n        if (node.length === 0 || node.length === 1 && node.first().is('space')) {\n          detected.push(false);\n        }\n      });\n\n      return detected;\n    }\n  };\n}();","/home/travis/build/npmtest/node-npmtest-csscomb/node_modules/csscomb/lib/options/sort-order-fallback.js":"'use strict';\n\nmodule.exports = {\n  name: 'sort-order-fallback',\n\n  syntax: ['css', 'less', 'sass', 'scss'],\n\n  accepts: { string: /^abc$/ },\n\n  process: function () {},\n\n  detect: () => []\n};","/home/travis/build/npmtest/node-npmtest-csscomb/node_modules/csscomb/lib/options/sort-order.js":"'use strict';\n\nvar gonzales = require('gonzales-pe');\n\nmodule.exports = {\n  get name() {\n    return 'sort-order';\n  },\n\n  get runBefore() {\n    return 'space-before-closing-brace';\n  },\n\n  get syntax() {\n    return ['css', 'less', 'sass', 'scss'];\n  },\n\n  /**\n   * @param {Array} value Option value\n   * @returns {Array}\n   */\n  setValue(value) {\n    if (!Array.isArray(value)) throw new Error('The option accepts only array of properties.');\n\n    var order = {};\n\n    if (typeof value[0] === 'string') {\n      // If there is only one group of properties.\n      value.forEach(function (prop, propIndex) {\n        order[prop] = { group: 0, prop: propIndex };\n      });\n    } else {\n      value.forEach(function (group, groupIndex) {\n        group.forEach(function (prop, propIndex) {\n          order[prop] = { group: groupIndex, prop: propIndex };\n        });\n      });\n    }\n\n    return order;\n  },\n\n  /**\n   * @param {node} ast\n   * @param {object} config\n   */\n  process(ast, config) {\n    this._config = config;\n    // Sort properties only inside blocks.\n    ast.traverseByType('block', this._processBlock.bind(this));\n  },\n\n  _cleanSassLinebreaks(node) {\n    let containsOnlyLinebreaks = true;\n\n    node.forEach(space => {\n      if (!space.is('space') || space.content !== '\\n') {\n        containsOnlyLinebreaks = false;\n        return null;\n      }\n    });\n\n    if (containsOnlyLinebreaks) node.content = [];\n  },\n\n  _extendNode(block, i, spacesBefore) {\n    let nodesToDelete = [i];\n    let node = block.get(i);\n    let extendedNode = { i: i, node: node };\n\n    let propertyName = this._getSortableName(node);\n    if (!propertyName) return null;\n\n    // Check if current node's property name is in sort order.\n    let propertyIndex = this.value[propertyName];\n    // If the declaration's property is in order's list, save its\n    // group and property indices. Otherwise set them to 10000, so\n    // declaration appears at the bottom of a sorted list:\n    extendedNode.groupIndex = propertyIndex && propertyIndex.group > -1 ? propertyIndex.group : this._getLastGroupIndex();\n    extendedNode.propertyIndex = propertyIndex && propertyIndex.prop > -1 ? propertyIndex.prop : this._getLastPropertyIndex();\n\n    // Spaces before node.\n    nodesToDelete = nodesToDelete.concat(spacesBefore);\n    extendedNode.spacesBeforeNode = this._getNodesByIndex(block, spacesBefore);\n\n    // Spaces after node.\n    let spacesBeforeDelimiter = this._getSpacesAndCommentsAfterNode(block, i);\n    nodesToDelete = nodesToDelete.concat(spacesBeforeDelimiter);\n    extendedNode.spacesBeforeDelimiter = this._getNodesByIndex(block, spacesBeforeDelimiter);\n\n    i += spacesBeforeDelimiter.length;\n\n    // Spaces after delimiter.\n    // If there is `;` right after the declaration, save it with the\n    // declaration and mark it for removing from parent node:\n    if (block.get(i + 1) && block.get(i + 1).is('declarationDelimiter')) {\n      i += 1;\n      node = block.get(i);\n      nodesToDelete.push(i);\n      extendedNode.delim = node;\n\n      if (node.syntax !== 'sass') {\n        // Save spaces and comments which follow right after\n        // the declaration and mark them for removing from parent node:\n        let spacesAfterDelimiter = this._getSpacesAndCommentsAfterNode(block, i);\n        i += spacesAfterDelimiter.length;\n        nodesToDelete = nodesToDelete.concat(spacesAfterDelimiter);\n        extendedNode.spacesAfterDelimiter = this._getNodesByIndex(block, spacesAfterDelimiter);\n      }\n    }\n\n    extendedNode.endIndex = i;\n    // Remove all nodes, that were moved to `sortables` list,\n    // from block node:\n    extendedNode.nodesToDelete = nodesToDelete;\n\n    return extendedNode;\n  },\n\n  _getLastGroupIndex() {\n    return this.value && this.value['...'] ? this.value['...'].group : Infinity;\n  },\n\n  _getLastPropertyIndex() {\n    return this.value && this.value['...'] ? this.value['...'].prop : Infinity;\n  },\n\n  _getNodesByIndex(block, index) {\n    return index.map(i => block.get(i));\n  },\n\n  _getSortableIncludeName(node) {\n    // Divide `include` into mixins with specific name\n    // (e. g. `$include breakpoint`), and the rest — `$include`.\n    let mixinName;\n\n    if (node.syntax === 'less') {\n      // `node.first()` is class and `node.first().first()` is ident.\n      mixinName = node.first().first().content;\n    } else if (node.syntax === 'sass' && node.first().content === '+') {\n      // `node.first()` is `+` and `node.get(1)` is ident.\n      mixinName = node.get(1).content;\n    } else {\n      // `node.first()` is @-keyword, `node.get(1)` is space and\n      // `node.get(2)` is ident.\n      mixinName = node.get(2).content;\n    }\n\n    let includeMixinName = '$include ' + mixinName;\n    return this.value.hasOwnProperty(includeMixinName) ? includeMixinName : '$include';\n  },\n\n  _getSortableName(node) {\n    if (node.is('extend')) return '$extend';\n    if (node.is('include')) return this._getSortableIncludeName(node);else return this._getSortablePropertyName(node);\n  },\n\n  _getSortablePropertyName(node) {\n    if (node.is('declaration')) {\n      let property = node.first('property').first();\n      return property.is('variable') ? '$variable' : property.content;\n    }\n\n    let atkeyword = node.first('atkeyword');\n    if (atkeyword && atkeyword.first().content === 'import') return '$import';\n  },\n\n  _getSpacesAndCommentsAfterNode(node, i) {\n    // List of start positions for nodes with spaces and comments:\n    let positions = [];\n\n    // Skip node itself.\n    i++;\n\n    for (let l = node.length; i < l; i++) {\n      let currentNode = node.get(i);\n\n      // If node is nor spaces neither comment, stop.\n      if (!this._isSpaceOrComment(currentNode)) break;\n\n      if (currentNode.is('multilineComment') || currentNode.is('singlelineComment')) {\n        positions.push(i);\n        continue;\n      }\n\n      // If there are any line breaks in a node with spaces, stop and\n      // split the node into two: one with spaces before line break\n      // and one with `\\n` symbol and everything that goes after.\n      // Combine the first one with declaration/@-rule's node:\n      let linebreakIndex = currentNode.content.indexOf('\\n');\n      if (linebreakIndex !== -1) {\n        var s = currentNode.content.substring(0, linebreakIndex);\n        if (s === '') break;\n        var space = gonzales.createNode({ type: 'space', content: s });\n        node.insert(i + 1, space);\n        positions.push(i + 1);\n        currentNode.content = currentNode.content.substring(linebreakIndex);\n        break;\n      }\n\n      positions.push(i);\n    }\n\n    return positions;\n  },\n\n  /**\n   * Check if there are any comments or spaces before\n   * the declaration/@-rule.\n   * @param {Node} node\n   * @param {Number} i\n   * @returns {Array} List of nodes with spaces and comments\n   */\n  _getSpacesAndCommentsBeforeNode(node, i) {\n    // List of start positions for nodes with spaces and comments:\n    let positions = [];\n    let sendPositions = false;\n\n    for (let l = node.length; i < l; i++) {\n      let currentNode = node.get(i);\n\n      // If the node is declaration or @-rule, stop and return all\n      // found nodes with spaces and comments (if there are any):\n      if (!this._isSpaceOrComment(currentNode)) {\n        sendPositions = true;\n        break;\n      }\n\n      positions.push(i);\n    }\n\n    return sendPositions ? positions : null;\n  },\n\n  _insertSortablesToBlock(nodesToSort, node) {\n    if (node.syntax === 'sass') this._cleanSassLinebreaks(node);\n\n    for (let i = nodesToSort.length - 1, l = -1; i > l; i--) {\n      let currentNode = nodesToSort[i];\n      let prevNode = nodesToSort[i - 1];\n      let spacesBeforeNode = currentNode.spacesBeforeNode || [];\n      let spacesBeforeDelimiter = currentNode.spacesBeforeDelimiter || [];\n      let spacesAfterDelimiter = currentNode.spacesAfterDelimiter || [];\n\n      if (node.syntax === 'sass' && spacesBeforeNode.length) {\n        let space = spacesBeforeNode[0];\n        space.content = space.content.replace(/\\n/, '');\n      }\n\n      spacesBeforeNode.reverse().map(this._removeEmptyLines);\n      spacesBeforeDelimiter.reverse().map(this._removeEmptyLines);\n      spacesAfterDelimiter.reverse().map(this._removeEmptyLines);\n\n      // Divide declarations from different groups with\n      // an empty line:\n      if (prevNode && currentNode.groupIndex > prevNode.groupIndex) {\n        let space = spacesBeforeNode[0];\n        if (space && space.is('space') && (space.syntax === 'sass' || space.content.match(/\\n/g) && space.content.match(/\\n/g).length < 2)) {\n          space.content = '\\n' + space.content;\n        }\n      }\n\n      for (let j = 0, nl = spacesAfterDelimiter.length; j < nl; j++) {\n        node.content.unshift(spacesAfterDelimiter[j]);\n      }\n\n      if (currentNode.delim) {\n        node.content.unshift(currentNode.delim);\n      } else if (i !== nodesToSort.length - 1 && (currentNode.node.is('declaration') || currentNode.node.is('extend'))) {\n        let delimiter = gonzales.createNode({\n          type: 'declarationDelimiter',\n          content: currentNode.node.syntax === 'sass' ? '\\n' : ';'\n        });\n        node.content.unshift(delimiter);\n      }\n\n      for (let j = 0, nl = spacesBeforeDelimiter.length; j < nl; j++) {\n        node.content.unshift(spacesBeforeDelimiter[j]);\n      }\n\n      node.content.unshift(currentNode.node);\n\n      for (let j = 0, nl = spacesBeforeNode.length; j < nl; j++) {\n        node.content.unshift(spacesBeforeNode[j]);\n      }\n    }\n  },\n\n  // Types of nodes that can be sorted.\n  _isAcceptableNode(node) {\n    const NODES = ['atrule', 'declaration', 'extend', 'include', 'multilineComment', 'singlelineComment', 'space'];\n    return NODES.indexOf(node.type) !== -1;\n  },\n\n  // Spaces and comments.\n  _isSpaceOrComment(node) {\n    const SC = ['multilineComment', 'singlelineComment', 'space'];\n    return SC.indexOf(node.type) !== -1;\n  },\n\n  _processBlock(block) {\n    // Check every child node.\n    // If it is declaration (property-value pair, e.g. `color: tomato`),\n    // or @-rule (e.g. `@include nani`),\n    // combine it with spaces, semicolon and comments and move them from\n    // current node to a separate list for further sorting:\n    let nodesToSort = this._separateSortablesFromBlock(block);\n    this._sortNodes(nodesToSort);\n    this._insertSortablesToBlock(nodesToSort, block);\n  },\n\n  /**\n   * Remove empty lines in space node.\n   * @param {node} node Space node.\n   */\n  _removeEmptyLines(node) {\n    node.content = node.content.replace(/\\n[\\s\\t\\n\\r]*\\n/, '\\n');\n  },\n\n  _separateSortablesFromBlock(block) {\n    let sortables = [];\n    let nodesToDelete = [];\n\n    // Don't cache `block.length` since we may insert new nodes into it.\n    for (let i = 0; i < block.length; i++) {\n      let node = block.get(i);\n      if (!this._isAcceptableNode(node)) continue;\n\n      // Save preceding spaces and comments, if there are any,\n      // and mark them for removing from parent node:\n      let spacesBeforeNode = this._getSpacesAndCommentsBeforeNode(block, i);\n      if (!spacesBeforeNode) break;\n\n      i += spacesBeforeNode.length;\n      node = block.get(i);\n\n      let extendedNode = this._extendNode(block, i, spacesBeforeNode);\n      if (!extendedNode) continue;\n\n      nodesToDelete = nodesToDelete.concat(extendedNode.nodesToDelete);\n      i = extendedNode.endIndex;\n      sortables.push(extendedNode);\n    }\n\n    nodesToDelete.sort((a, b) => a - b);\n    for (let x = nodesToDelete.length - 1; x > -1; x--) block.removeChild(nodesToDelete[x]);\n\n    return sortables;\n  },\n\n  _sortLeftovers(a, b) {\n    let prefixes = ['-webkit-', '-moz-', '-ms-', '-o-', ''];\n    let prefixesRegExp = /^(-webkit-|-moz-|-ms-|-o-)(.*)$/;\n\n    // Get property name (i.e. `color`, `-o-animation`):\n    a = a.node.first().first().content;\n    b = b.node.first().first().content;\n\n    // Get prefix and unprefixed part. For example:\n    // ['-o-animation', '-o-', 'animation']\n    // ['color', '', 'color']\n    a = a.match(prefixesRegExp) || [a, '', a];\n    b = b.match(prefixesRegExp) || [b, '', b];\n\n    if (a[2] !== b[2]) {\n      // If unprefixed parts are different (i.e. `border` and\n      // `color`), compare them:\n      return a[2] <= b[2] ? -1 : 1;\n    } else {\n      // If unprefixed parts are identical (i.e. `border` in\n      // `-moz-border` and `-o-border`), compare prefixes.\n      // They should go in the same order they are set\n      // in `prefixes` array.\n      return prefixes.indexOf(a[1]) <= prefixes.indexOf(b[1]) ? -1 : 1;\n    }\n  },\n\n  _sortNodes(nodes) {\n    nodes.sort((a, b) => {\n      // If a's group index is higher than b's group index, in\n      // a sorted list a appears after b:\n      if (a.groupIndex !== b.groupIndex) return a.groupIndex - b.groupIndex;\n\n      // If a and b belong to leftovers and `sort-order-fallback`\n      // option is set to `abc`, sort properties alphabetically:\n      if (a.groupIndex === this._getLastGroupIndex() && this._config['sort-order-fallback']) {\n        return this._sortLeftovers(a, b);\n      }\n\n      // If a and b have the same group index, and a's property index\n      // is higher than b's property index, in a sorted list\n      // a appears after b:\n      if (a.propertyIndex !== b.propertyIndex) return a.propertyIndex - b.propertyIndex;\n\n      // If a and b have the same group index and the same property\n      // index, in a sorted list they appear in the same order\n      // they were in original array:\n      return a.i - b.i;\n    });\n  },\n\n  detect: () => []\n};","/home/travis/build/npmtest/node-npmtest-csscomb/node_modules/csscomb/lib/options/space-after-colon.js":"'use strict';\n\nvar gonzales = require('gonzales-pe');\n\nmodule.exports = {\n  name: 'space-after-colon',\n\n  runBefore: 'block-indent',\n\n  syntax: ['css', 'less', 'sass', 'scss'],\n\n  accepts: {\n    number: true,\n    string: /^[ \\t\\n]*$/\n  },\n\n  /**\n   * Processes tree node.\n   *\n   * @param {node} ast\n   */\n  process: function (ast) {\n    let value = this.value;\n\n    ast.traverseByType('propertyDelimiter', function (delimiter, i, parent) {\n      if (delimiter.syntax === 'sass' && !parent.get(i - 1)) return null;\n\n      // Remove any spaces after colon:\n      if (parent.get(i + 1).is('space')) parent.removeChild(i + 1);\n      // If the value set in config is not empty, add spaces:\n      if (value !== '') {\n        var space = gonzales.createNode({\n          type: 'space',\n          content: value\n        });\n        parent.insert(i + 1, space);\n      }\n\n      return null;\n    });\n  },\n\n  /**\n   * Detects the value of an option at the tree node.\n   *\n   * @param {node} ast\n   */\n  detect: function (ast) {\n    let detected = [];\n\n    ast.traverseByType('propertyDelimiter', function (delimiter, i, parent) {\n      if (parent.get(i + 1).is('space')) {\n        detected.push(parent.get(i + 1).content);\n      } else {\n        detected.push('');\n      }\n    });\n\n    return detected;\n  }\n};","/home/travis/build/npmtest/node-npmtest-csscomb/node_modules/csscomb/lib/options/space-after-combinator.js":"'use strict';\n\nvar gonzales = require('gonzales-pe');\n\nmodule.exports = {\n  name: 'space-after-combinator',\n\n  runBefore: 'block-indent',\n\n  syntax: ['css', 'less', 'sass', 'scss'],\n\n  accepts: {\n    number: true,\n    string: /^[ \\t\\n]*$/\n  },\n\n  /**\n   * Processes tree node.\n   *\n   * @param {node} ast\n   */\n  process: function (ast) {\n    let value = this.value;\n\n    ast.traverseByType('combinator', function (combinator, i, parent) {\n      if (parent.get(i + 1).is('space')) {\n        parent.get(i + 1).content = value;\n      } else {\n        var space = gonzales.createNode({\n          type: 'space',\n          content: value\n        });\n        parent.insert(i + 1, space);\n      }\n    });\n  },\n\n  /**\n   * Detects the value of an option at the tree node.\n   *\n   * @param {node} ast\n   */\n  detect: function (ast) {\n    let detected = [];\n\n    ast.traverseByType('combinator', function (combinator, i, parent) {\n      if (parent.get(i + 1).is('space')) {\n        detected.push(parent.get(i + 1).content);\n      } else {\n        detected.push('');\n      }\n    });\n\n    return detected;\n  }\n};","/home/travis/build/npmtest/node-npmtest-csscomb/node_modules/csscomb/lib/options/space-after-opening-brace.js":"'use strict';\n\nvar gonzales = require('gonzales-pe');\n\nmodule.exports = {\n  name: 'space-after-opening-brace',\n\n  runBefore: 'block-indent',\n\n  syntax: ['css', 'less', 'scss'],\n\n  accepts: {\n    number: true,\n    string: /^[ \\t\\n]*$/\n  },\n\n  /**\n   * Processes tree node.\n   *\n   * @param {node} ast\n   */\n  process: function (ast) {\n    let value = this.value;\n\n    ast.traverse(function (node) {\n      // If found block node stop at the next one for space check\n      if (!node.is('block') && !node.is('atrulers')) return;\n\n      if (node.first() && node.first().is('space')) {\n        node.first().content = value;\n      } else if (value !== '') {\n        var space = gonzales.createNode({\n          type: 'space',\n          content: value\n        });\n        node.insert(0, space);\n      }\n    });\n  },\n\n  /**\n   * Detects the value of an option at the tree node.\n   *\n   * @param {node} ast\n   */\n  detect: function (ast) {\n    let detected = [];\n\n    ast.traverse(function (node) {\n      if (!node.is('block') && !node.is('atrulers')) return;\n\n      if (node.first().is('space')) {\n        detected.push(node.first().content);\n      } else {\n        detected.push('');\n      }\n    });\n\n    return detected;\n  }\n};","/home/travis/build/npmtest/node-npmtest-csscomb/node_modules/csscomb/lib/options/space-after-selector-delimiter.js":"'use strict';\n\nvar gonzales = require('gonzales-pe');\n\nmodule.exports = {\n  name: 'space-after-selector-delimiter',\n\n  runBefore: 'block-indent',\n\n  syntax: ['css', 'less', 'sass', 'scss'],\n\n  accepts: {\n    number: true,\n    string: /^[ \\t\\n]*$/\n  },\n\n  /**\n   * Processes tree node.\n   *\n   * @param {node} ast\n   */\n  process: function (ast) {\n    let value = this.value;\n\n    ast.traverseByType('delimiter', function (delimiter, i, parent) {\n      if (parent.is('arguments')) return;\n\n      var nextNode = parent.get(i + 1);\n\n      if (nextNode.is('space')) {\n        nextNode.content = value;\n      } else if (nextNode.first().is('space')) {\n        nextNode.first().content = value;\n      } else {\n        var space = gonzales.createNode({\n          type: 'space',\n          content: value\n        });\n        nextNode.insert(0, space);\n      }\n    });\n  },\n\n  /**\n   * Detects the value of an option at the tree node.\n   *\n   * @param {node} ast\n   */\n  detect: function (ast) {\n    let detected = [];\n\n    ast.traverseByType('delimiter', function (delimiter, i, parent) {\n      if (parent.is('arguments')) return;\n\n      var nextNode = parent.get(i + 1);\n\n      if (nextNode && nextNode.is('space')) {\n        detected.push(nextNode.content);\n      } else if (nextNode.first() && nextNode.first().is('space')) {\n        detected.push(nextNode.first().content);\n      } else {\n        detected.push('');\n      }\n    });\n\n    return detected;\n  }\n};","/home/travis/build/npmtest/node-npmtest-csscomb/node_modules/csscomb/lib/options/space-before-closing-brace.js":"'use strict';\n\nvar gonzales = require('gonzales-pe');\n\nmodule.exports = function () {\n  var valueFromSettings;\n  var blockIndent;\n\n  function getLastWhitespaceNode(node) {\n    var lastNode = node.last();\n\n    if (!lastNode || !lastNode.content) return null;\n\n    if (lastNode.is('block')) return null;\n    if (lastNode.is('space')) return lastNode;\n\n    return getLastWhitespaceNode(lastNode);\n  }\n\n  function processBlock(x, level) {\n    level = level || 0;\n\n    x.forEach(function (node) {\n      if (!node.is('block') && !node.is('atrulers')) return processBlock(node, level);\n\n      level++;\n\n      var value = valueFromSettings;\n      if (value.indexOf('\\n') > -1) {\n        // TODO: Check that it works for '' block indent value <tg>\n        if (blockIndent) {\n          value += new Array(level).join(blockIndent);\n        }\n      }\n\n      // If found block node stop at the next one for space check\n      // For the pre-block node, find its last (the deepest) child\n      var whitespaceNode = getLastWhitespaceNode(node);\n\n      // If it's spaces, modify this node\n      // If it's something different from spaces, add a space node\n      // to the end\n      if (whitespaceNode) {\n        whitespaceNode.content = value;\n      } else if (value !== '') {\n        var space = gonzales.createNode({\n          type: 'space',\n          content: value\n        });\n        node.content.push(space);\n      }\n\n      processBlock(node, level);\n    });\n  }\n\n  return {\n    name: 'space-before-closing-brace',\n\n    runBefore: 'tab-size',\n\n    syntax: ['css', 'less', 'scss'],\n\n    accepts: {\n      number: true,\n      string: /^[ \\t\\n]*$/\n    },\n\n    /**\n     * Processes tree node.\n     * @param {node} ast\n     * @param {Object} config\n     */\n    process: function (ast, config) {\n      valueFromSettings = this.value;\n      blockIndent = config['block-indent'];\n\n      processBlock(ast);\n    },\n\n    /**\n     * Detects the value of an option at the tree node.\n     *\n     * @param {node} ast\n     */\n    detect: function (ast) {\n      let detected = [];\n\n      ast.traverseByTypes(['block', 'atrulers'], function (node) {\n        // For the block node, find its last (the deepest) child\n        var whitespaceNode = getLastWhitespaceNode(node);\n        if (whitespaceNode) {\n          detected.push(whitespaceNode.content);\n        } else {\n          detected.push('');\n        }\n      });\n\n      return detected;\n    }\n  };\n}();","/home/travis/build/npmtest/node-npmtest-csscomb/node_modules/csscomb/lib/options/space-before-colon.js":"'use strict';\n\nvar gonzales = require('gonzales-pe');\n\nmodule.exports = {\n  name: 'space-before-colon',\n\n  runBefore: 'block-indent',\n\n  syntax: ['css', 'less', 'sass', 'scss'],\n\n  accepts: {\n    number: true,\n    string: /^[ \\t\\n]*$/\n  },\n\n  /**\n   * Processes tree node.\n   *\n   * @param {node} ast\n   */\n  process: function (ast) {\n    let value = this.value;\n\n    ast.traverseByType('propertyDelimiter', function (delimiter, i, parent) {\n      if (delimiter.syntax === 'sass' && !parent.get(i - 1)) return;\n\n      // Remove any spaces before colon:\n      if (parent.get(i - 1).is('space')) {\n        parent.removeChild(--i);\n      }\n\n      // If the value set in config is not empty, add spaces:\n      if (value !== '') {\n        var space = gonzales.createNode({\n          type: 'space',\n          content: value\n        });\n        parent.insert(i, space);\n      }\n    });\n  },\n\n  /**\n   * Detects the value of an option at the tree node.\n   *\n   * @param {node} ast\n   */\n  detect: function (ast) {\n    let detected = [];\n\n    ast.traverseByType('propertyDelimiter', function (delimiter, i, parent) {\n      if (parent.get(i - 1).is('space')) {\n        detected.push(parent.get(i - 1).content);\n      } else {\n        detected.push('');\n      }\n    });\n\n    return detected;\n  }\n};","/home/travis/build/npmtest/node-npmtest-csscomb/node_modules/csscomb/lib/options/space-before-combinator.js":"'use strict';\n\nvar gonzales = require('gonzales-pe');\n\nmodule.exports = {\n  name: 'space-before-combinator',\n\n  runBefore: 'block-indent',\n\n  syntax: ['css', 'less', 'sass', 'scss'],\n\n  accepts: {\n    number: true,\n    string: /^[ \\t\\n]*$/\n  },\n\n  /**\n   * Processes tree node.\n   *\n   * @param {node} ast\n   */\n  process: function (ast) {\n    let value = this.value;\n\n    ast.traverseByType('combinator', function (combinator, i, parent) {\n      if (parent.get(i - 1).is('space')) {\n        parent.get(i - 1).content = value;\n      } else {\n        var space = gonzales.createNode({\n          type: 'space',\n          content: value\n        });\n        parent.insert(i, space);\n      }\n    });\n  },\n\n  /**\n   * Detects the value of an option at the tree node.\n   *\n   * @param {node} ast\n   */\n  detect: function (ast) {\n    let detected = [];\n\n    ast.traverseByType('combinator', function (combinator, i, parent) {\n      if (parent.get(i - 1).is('space')) {\n        detected.push(parent.get(i - 1).content);\n      } else {\n        detected.push('');\n      }\n    });\n\n    return detected;\n  }\n};","/home/travis/build/npmtest/node-npmtest-csscomb/node_modules/csscomb/lib/options/space-before-opening-brace.js":"'use strict';\n\nvar gonzales = require('gonzales-pe');\n\nmodule.exports = function () {\n  return {\n    name: 'space-before-opening-brace',\n\n    runBefore: 'block-indent',\n\n    syntax: ['css', 'less', 'scss'],\n\n    accepts: {\n      number: true,\n      string: /^[ \\t\\n]*$/\n    },\n\n    /**\n     * Processes tree node.\n     *\n     * @param {node} ast\n     */\n    process: function (ast) {\n      let value = this.value;\n\n      // If found block node stop at the next one for space check.\n      ast.traverseByTypes(['block', 'value'], function (block, i, parent) {\n        if (block.is('value') && !block.first().is('block')) return;\n\n        var previousNode = parent.get(i - 1);\n        if (!previousNode) return;\n\n        // If it's spaces, modify this node.\n        // If it's something different from spaces, add a space node to\n        // the end:\n        if (previousNode.is('space')) {\n          previousNode.content = value;\n        } else if (value !== '') {\n          var space = gonzales.createNode({\n            type: 'space',\n            content: value\n          });\n          parent.insert(i, space);\n        }\n      });\n    },\n\n    /**\n     * Detects the value of an option at the tree node.\n     *\n     * @param {node} ast\n     */\n    detect: function (ast) {\n      var detected = [];\n\n      ast.traverseByTypes(['block', 'value'], function (block, i, parent) {\n        if (block.is('value') && !block.first().is('block')) return;\n\n        var previousNode = parent.get(i - 1);\n        if (!previousNode) return;\n\n        // If it's spaces, modify this node.\n        // If it's something different from spaces, add a space node to\n        // the end:\n        if (previousNode.is('space')) {\n          detected.push(previousNode.content);\n        } else {\n          detected.push('');\n        }\n      });\n\n      return detected;\n    }\n  };\n}();","/home/travis/build/npmtest/node-npmtest-csscomb/node_modules/csscomb/lib/options/space-before-selector-delimiter.js":"'use strict';\n\nvar gonzales = require('gonzales-pe');\n\nmodule.exports = {\n  name: 'space-before-selector-delimiter',\n\n  runBefore: 'block-indent',\n\n  syntax: ['css', 'less', 'sass', 'scss'],\n\n  accepts: {\n    number: true,\n    string: /^[ \\t\\n]*$/\n  },\n\n  /**\n   * Processes tree node.\n   *\n   * @param {node} ast\n   */\n  process: function (ast) {\n    let value = this.value;\n\n    ast.traverseByType('delimiter', function (delimiter, i, parent) {\n      if (parent.is('arguments')) return;\n\n      var previousNode = parent.get(i - 1);\n      if (previousNode.is('space')) {\n        previousNode.content = value;\n      } else {\n        var space = gonzales.createNode({\n          type: 'space',\n          content: value\n        });\n        parent.insert(i, space);\n      }\n    });\n  },\n\n  /**\n   * Detects the value of an option at the tree node.\n   *\n   * @param {node} ast\n   */\n  detect: function (ast) {\n    let detected = [];\n\n    ast.traverseByType('delimiter', function (delimiter, i, parent) {\n      if (parent.is('arguments')) return;\n\n      var previousNode = parent.get(i - 1);\n      if (previousNode.is('space')) {\n        detected.push(previousNode.content);\n      } else {\n        detected.push('');\n      }\n    });\n\n    return detected;\n  }\n};","/home/travis/build/npmtest/node-npmtest-csscomb/node_modules/csscomb/lib/options/space-between-declarations.js":"'use strict';\n\nvar gonzales = require('gonzales-pe');\n\nmodule.exports = function () {\n  function getDeclarationEnd(node, i) {\n    for (; i < node.length; i++) {\n      if (!node.get(i + 1) || typeof node.get(i + 1) === 'string') {\n        return 0;\n      } else if (node.get(i + 1).is('space')) {\n        if (node.get(i + 1).content.indexOf('\\n') > -1) {\n          if (node.get(i + 2) && node.get(i + 2).is('declaration')) {\n            return i;\n          } else {\n            return 0;\n          }\n        } else if (node.get(i + 2) && node.get(i + 2).is('multilineComment')) {\n          if (node.get(i + 3) && node.get(i + 3).is('declaration')) {\n            return i + 2;\n          } else if (node.get(i + 3) && node.get(i + 3).is('space')) {\n            if (node.get(i + 4) && node.get(i + 4).is('declaration')) {\n              return i + 2;\n            } else {\n              return 0;\n            }\n          } else {\n            return 0;\n          }\n        } else if (node.get(i + 2) && node.get(i + 2).is('declaration')) {\n          return i;\n        }\n      } else if (node.get(i + 1).is('declaration')) {\n        return i;\n      } else if (node.get(i + 1).is('multilineComment')) {\n        if (node.get(i + 2) && node.get(i + 2).is('declaration')) {\n          return i + 1;\n        } else if (node.get(i + 2) && node.get(i + 2).is('space')) {\n          if (node.get(i + 3) && node.get(i + 3).is('declaration')) {\n            return i + 1;\n          }\n        } else {\n          return 0;\n        }\n      } else {\n        return 0;\n      }\n    }\n  }\n\n  return {\n    name: 'space-between-declarations',\n\n    runBefore: 'block-indent',\n\n    syntax: ['css', 'less', 'scss'],\n\n    accepts: {\n      number: true,\n      string: /^[ \\t\\n]*$/\n    },\n\n    /**\n     * Processes tree node.\n     *\n     * @param {node} ast\n     */\n    process: function (ast) {\n      let value = this.value;\n\n      ast.traverseByType('declarationDelimiter', (delimiter, i, parent) => {\n        // Grom user's point of view \"declaration\" includes semicolons\n        // and comments placed on the same line.\n        // So group those things together:\n        var declarationEnd = getDeclarationEnd(parent, i);\n        if (!declarationEnd) {\n          return;\n        } else {\n          i = declarationEnd;\n        }\n\n        var nextNode = parent.get(i + 1);\n        if (nextNode.is('space')) {\n          nextNode.content = value;\n        } else {\n          var space = gonzales.createNode({\n            type: 'space',\n            content: value\n          });\n          parent.insert(i + 1, space);\n        }\n      });\n    }\n  };\n}();","/home/travis/build/npmtest/node-npmtest-csscomb/node_modules/csscomb/lib/options/strip-spaces.js":"'use strict';\n\nmodule.exports = function () {\n  /**\n   * Trim trailing spaces on each line.\n   * @private\n   * @param {String} string Spaceful string\n   * @returns {String}\n   */\n  function trim(string) {\n    return string.replace(/[ \\t]+\\n/g, '\\n');\n  }\n\n  return {\n    name: 'strip-spaces',\n\n    syntax: ['css', 'less', 'sass', 'scss'],\n\n    accepts: {\n      boolean: [true]\n    },\n\n    /**\n     * Processes tree node.\n     * @param {node} ast\n     */\n    process: function (ast) {\n      var lastChild = ast.last();\n      if (lastChild.is('space')) {\n        lastChild.content = trim(lastChild.content).replace(/[ \\t]+$/, '').replace(/[\\n]+/g, '\\n');\n      }\n\n      ast.traverseByType('space', function (space) {\n        space.content = trim(space.content);\n      });\n    },\n\n    detectDefault: true,\n\n    /**\n     * Detects the value of an option at the tree node.\n     * This option is treated as `true` by default, but any trailing\n     * space would invalidate it.\n     *\n     * @param {node} ast\n     */\n    detect: function (ast) {\n      let detected = [];\n\n      var lastChild = ast.last();\n      if (lastChild.is('space') && lastChild.content !== '\\n' && lastChild.content.match(/^[ \\n\\t]+$/)) {\n        detected.push(false);\n      }\n\n      ast.traverseByType('space', function (space) {\n        if (space.content.match(/[ \\t]\\n/)) detected.push(false);\n      });\n\n      return detected;\n    }\n  };\n}();","/home/travis/build/npmtest/node-npmtest-csscomb/node_modules/csscomb/lib/options/tab-size.js":"'use strict';\n\nmodule.exports = {\n  name: 'tab-size',\n\n  runBefore: 'vendor-prefix-align',\n\n  syntax: ['css', 'less', 'sass', 'scss'],\n\n  accepts: {\n    number: true\n  },\n\n  /**\n   * Processes tree node.\n   *\n   * @param {node} ast\n   */\n  process: function (ast) {\n    let value = this.value;\n\n    ast.traverseByType('space', function (space) {\n      space.content = space.content.replace(/\\t/, value);\n    });\n  }\n};","/home/travis/build/npmtest/node-npmtest-csscomb/node_modules/csscomb/lib/options/unitless-zero.js":"'use strict';\n\nmodule.exports = {\n  name: 'unitless-zero',\n\n  syntax: ['css', 'less', 'sass', 'scss'],\n\n  accepts: {\n    boolean: [true]\n  },\n\n  /**\n   * Processes tree node.\n   *\n   * @param {node} ast\n   */\n  process: function (ast) {\n    var UNITS = ['cm', 'em', 'ex', 'pt', 'px'];\n\n    ast.traverseByTypes(['value', 'parentheses'], function (node) {\n      node.forEach(function (value) {\n        if (typeof value === 'string') return;\n\n        if (value.is('dimension')) {\n          var unit = value.first('ident').content;\n          if (value.first('number').content === '0' && UNITS.indexOf(unit) !== -1) {\n            value.removeChild(1);\n          }\n        } else if (value.is('percentage')) {\n          var number = value.first('number').content;\n          if (number === '0') {\n            value.type = 'number';\n            value.content = number;\n          }\n        }\n      });\n    });\n  },\n\n  /**\n   * Detects the value of an option at the tree node.\n   *\n   * @param {node} ast\n   */\n  detect: function (ast) {\n    let detected = [];\n\n    ast.traverse(function (node, index, parent) {\n      // If we see a zero with unit and it is not degree,\n      // then we don’t have an option\n      if (node.is('percentage') && node.first('number').content[1] === '0') {\n        detected.push(false);\n        return;\n      }\n\n      if (node.is('dimension') && node.first('number').content === '0' && node.first('ident').content !== 'deg') {\n        detected.push(false);\n        return;\n      }\n\n      // If we see a zero and previous node is not percentage\n      // or dimension, then we have an option\n      if (node.is('number') && node.content === '0' && !parent.is('percentage') && !parent.is('dimension')) {\n        detected.push(true);\n      }\n    });\n\n    return detected;\n  }\n};","/home/travis/build/npmtest/node-npmtest-csscomb/node_modules/csscomb/lib/options/vendor-prefix-align.js":"'use strict';\n\nvar gonzales = require('gonzales-pe');\n\nmodule.exports = function () {\n  // Vendor prefixes list:\n  var PREFIXES = ['webkit', 'khtml', 'moz', 'ms', 'o'];\n\n  var oneline;\n\n  /**\n   * Makes namespace from property name.\n   *\n   * @param {String} propertyName\n   * @returns {String|undefined}\n   */\n  function makeNamespace(propertyName) {\n    var info = getPrefixInfo(propertyName);\n    return info && info.baseName;\n  }\n\n  /**\n   * Creates object which contains info about vendor prefix used\n   * in propertyName.\n   *\n   * @param {String} propertyName property name\n   * @param {String} [namespace=''] namespace name\n   * @param {Number} [extraSymbols=0] extra symbols count\n   * @returns {Object|undefined}\n   */\n  function getPrefixInfo(propertyName, namespace, extraSymbols) {\n    var baseName = propertyName;\n    var prefixLength = 0;\n\n    namespace = namespace || '';\n    extraSymbols = extraSymbols || 0;\n\n    if (!propertyName) return;\n\n    PREFIXES.some(function (prefix) {\n      prefix = '-' + prefix + '-';\n      if (propertyName.indexOf(prefix) !== 0) return;\n\n      baseName = baseName.substr(prefix.length);\n      prefixLength = prefix.length;\n\n      return true;\n    });\n\n    return {\n      id: namespace + baseName,\n      baseName: baseName,\n      prefixLength: prefixLength,\n      extra: extraSymbols\n    };\n  }\n\n  /**\n   * Returns extra indent for item in arguments\n   *\n   * @param {Array} nodes nodes to process\n   * @returns {Number|undefined}\n   */\n  function extraIndent(nodes) {\n    if (!nodes || !nodes.length) return;\n\n    var node;\n    var crPos;\n    var tabPos;\n    var result = 0;\n\n    for (var i = nodes.length; i--;) {\n      node = nodes[i];\n\n      if (!node.content) {\n        crPos = -1;\n      } else {\n        crPos = node.content.lastIndexOf('\\n');\n        tabPos = node.content.lastIndexOf('\\t');\n        if (tabPos > crPos) crPos = tabPos;\n      }\n\n      if (crPos !== -1) oneline = false;\n\n      if (node.is('space')) {\n        result += node.content.length - crPos - 1;\n        if (crPos !== -1) break;\n      }\n      if (node.is('multilineComment')) {\n        if (crPos === -1) {\n          // Comment symbols length\n          let offset = 4;\n          result += node.content.length + offset;\n        } else {\n          // Only last comment symbols length - 1 (not count \\n)\n          let offset = crPos - 1;\n          result += node.content.length - offset;\n          break;\n        }\n      }\n    }\n\n    return result;\n  }\n\n  /**\n   * Wrapper for extra indent function for `property` node.\n   *\n   * @param {Array} nodes all nodes\n   * @param {Number} i position in nodes array\n   */\n  function extraIndentProperty(nodes, i) {\n    var subset = [];\n    while (i--) {\n      if (!nodes.get(i) || nodes.get(i).is('declarationDelimiter')) break;\n      subset.unshift(nodes.get(i));\n    }\n    return extraIndent(subset);\n  }\n\n  /**\n   * Wrapper for extra indent function for val-node.\n   *\n   * @param {Array} nodes all nodes\n   * @param {Number} i position in nodes array\n   */\n  function extraIndentVal(nodes, i) {\n    var subset = [];\n    var declaration = nodes.get(i);\n    if (!declaration.is('declaration')) return;\n\n    for (var x = declaration.length; x--;) {\n      if (!declaration.get(x).is('value')) continue;\n\n      x--;\n\n      while (!declaration.get(x).is('propertyDelimiter')) {\n        subset.push(declaration.get(x));\n        x--;\n      }\n\n      break;\n    }\n    return extraIndent(subset);\n  }\n\n  /**\n   * Walks across nodes, and call payload for every node that pass\n   * selector check.\n   *\n   * @param {Object} args arguments in form of:\n   *  {\n   *      node: {object} current node,\n   *      selector: {function} propertyName selector\n   *      payload: {function} work to do with gathered info\n   *      namespaceSelector: {function} selector for namespace\n   *      getExtraSymbols: {Number} extra symbols count\n   *  }\n   */\n  function walk(args) {\n    args.node.forEach(function (item, i) {\n      var name = args.selector(item);\n      var namespace = args.namespaceSelector && makeNamespace(args.namespaceSelector(item));\n      var extraSymbols = args.getExtraSymbols(args.node, i);\n\n      var info = name && getPrefixInfo(name, namespace, extraSymbols);\n      if (!info) return;\n      args.payload(info, i);\n    });\n  }\n\n  /**\n   * Returns property name.\n   * e.g.\n   * for: 'color: #fff'\n   * returns string: 'color'\n   *\n   * @param {node} node\n   * @returns {String|undefined}\n   */\n  function getPropertyName(node) {\n    if (!node.is('declaration')) return;\n    // TODO: Check that it's not a variable\n    return node.get(0).get(0).content;\n  }\n\n  /**\n   * Returns property value name.\n   * e.g.\n   * for: '-webkit-transition: -webkit-transform 150ms linear'\n   * returns string: '-webkit-transform', and\n   * for: 'background: -webkit-linear-gradient(...)'\n   * returns string: '-webkit-linear-gradient'\n   *\n   * @param {node} node\n   * @returns {String|undefined}\n   */\n  function getValName(node) {\n    if (!node.is('declaration')) return;\n\n    var value = node.first('value');\n    if (value.get(0).is('ident')) return value.get(0).content;\n    if (value.get(0).is('function')) return value.get(0).get(0).content;\n  }\n\n  /**\n   * Updates dict which contains info about items align.\n   *\n   * @param {Object} info\n   * @param {Object} dict\n   */\n  function updateDict(info, dict) {\n    if (info.prefixLength === 0 && info.extra === 0) return;\n\n    var indent = dict[info.id] || { prefixLength: 0, extra: 0 };\n\n    let indentLength = indent.prefixLength + indent.extra;\n    let infoLength = info.prefixLength + info.extra;\n    if (indentLength > infoLength) {\n      dict[info.id] = indent;\n    } else {\n      dict[info.id] = {\n        prefixLength: info.prefixLength,\n        extra: info.extra\n      };\n    }\n  }\n\n  /**\n   * Returns string with correct number of spaces for info.baseName property.\n   *\n   * @param {Object} info\n   * @param {Object} dict\n   * @param {String} whitespaceNode\n   * @returns {String}\n   */\n  function updateIndent(info, dict, whitespaceNode) {\n    var item = dict[info.id];\n    if (!item) return whitespaceNode;\n\n    var crPos = whitespaceNode.lastIndexOf('\\n');\n    var tabPos = whitespaceNode.lastIndexOf('\\t');\n    if (tabPos > crPos) crPos = tabPos;\n\n    var firstPart = whitespaceNode.substr(0, crPos + 1);\n    var extraIndent = new Array(item.prefixLength - info.prefixLength + (item.extra - info.extra) + whitespaceNode.length - firstPart.length + 1).join(' ');\n\n    return firstPart.concat(extraIndent);\n  }\n\n  return {\n    name: 'vendor-prefix-align',\n\n    syntax: ['css', 'less', 'sass', 'scss'],\n\n    accepts: {\n      boolean: [true]\n    },\n\n    /**\n     * Processes tree node.\n     *\n     * @param {node} ast\n     */\n    process: function (ast) {\n      ast.traverseByType('block', function (node) {\n        oneline = true;\n\n        var dict = {};\n\n        // Gathering Info\n        walk({\n          node: node,\n          selector: getPropertyName,\n          getExtraSymbols: extraIndentProperty,\n          payload: function (info) {\n            updateDict(info, dict);\n          }\n        });\n\n        walk({\n          node: node,\n          selector: getValName,\n          namespaceSelector: getPropertyName,\n          getExtraSymbols: extraIndentVal,\n          payload: function (info) {\n            updateDict(info, dict);\n          }\n        });\n\n        if (oneline && ast.syntax !== 'sass') return;\n\n        // Update nodes\n        walk({\n          node: node,\n          selector: getValName,\n          namespaceSelector: getPropertyName,\n          getExtraSymbols: extraIndentVal,\n          payload: function (info, i) {\n            for (var x = node.get(i).length; x--;) {\n              if (node.get(i).get(x).is('value')) break;\n            }\n\n            let prevNode = node.get(i).get(x - 1);\n            if (!prevNode.is('space')) {\n              var space = gonzales.createNode({\n                type: 'space',\n                content: ''\n              });\n              node.get(i).insert(x, space);\n              ++x;\n            }\n\n            let content = node.get(i).get(x - 1).content;\n            let updatedIndent = updateIndent(info, dict, content);\n            node.get(i).get(x - 1).content = updatedIndent;\n          }\n        });\n\n        if (ast.syntax === 'sass') return;\n\n        walk({\n          node: node,\n          selector: getPropertyName,\n          getExtraSymbols: extraIndentProperty,\n          payload: function (info, i) {\n            // `node.get(i - 1)` can be either space or comment:\n            var whitespaceNode = node.get(i - 1);\n            if (!whitespaceNode) return;\n            // If it's a comment, insert an empty space node:\n            if (!whitespaceNode.is('space')) {\n              whitespaceNode = gonzales.createNode({\n                type: 'space',\n                content: ''\n              });\n              node.insert(i - 1, whitespaceNode);\n            }\n            let content = whitespaceNode.content;\n            let updatedContent = updateIndent(info, dict, content);\n            whitespaceNode.content = updatedContent;\n          }\n        });\n      });\n    },\n\n    /**\n     * Detects the value of an option at the tree node.\n     *\n     * @param {node} ast\n     */\n    detect: function (ast) {\n      let detected = [];\n\n      ast.traverseByType('block', function (node) {\n        var result = {\n          true: 0,\n          false: 0\n        };\n\n        var maybePrefix = false;\n        var prevPrefixLength = false;\n        var prevProp;\n        var prevSum;\n        var partialResult = null;\n\n        var getResult = function (options) {\n          let node = options.node,\n              sum = options.sum,\n              info = options.info,\n              i = options.i;\n\n          var prop = info.baseName;\n\n          // If this is the last item in a row and we have a result,\n          // then catch it\n          if (prop !== prevProp && partialResult !== null) {\n            if (partialResult) {\n              result.true++;\n            } else {\n              result.false++;\n            }\n            partialResult = null;\n          }\n\n          if (prop === prevProp && info.prefixLength !== prevPrefixLength) {\n            maybePrefix = true;\n          } else {\n            maybePrefix = false;\n          }\n\n          if (maybePrefix && partialResult !== false) {\n            // If there is prefixed prop, check if the prefixes are\n            // aligned, but only if we hadn't already catched\n            // that it is false\n            if (sum === prevSum) {\n              partialResult = true;\n            } else {\n              partialResult = false;\n            }\n          }\n\n          if (node.length === i + 3 && partialResult !== null) {\n            // If we're at the last property and have a result,\n            // catch it\n            if (partialResult) {\n              result.true++;\n            } else {\n              result.false++;\n            }\n          }\n\n          prevPrefixLength = info.prefixLength;\n          prevProp = prop;\n          prevSum = sum;\n        };\n\n        // Gathering Info\n        walk({\n          node: node,\n          selector: getPropertyName,\n          getExtraSymbols: extraIndentProperty,\n          payload: function (info, i) {\n            if (node.get(i - 1) && node.get(i - 1).content) {\n              let nodeLength = node.get(i - 1).content.replace(/^[ \\t]*\\n+/, '').length;\n              var sum = nodeLength + info.prefixLength;\n              getResult({ node: node, sum: sum, info: info, i: i });\n            }\n          }\n        });\n\n        walk({\n          node: node,\n          selector: getValName,\n          getExtraSymbols: extraIndentVal,\n          payload: function (info, i) {\n            for (var x = node.get(i).length; x--;) {\n              if (node.get(i).get(x).is('value')) break;\n            }\n\n            if (node.get(i).get(x - 1)) {\n              let nodeLength = node.get(i).get(x - 1).content.replace(/^[ \\t]*\\n+/, '').length;\n              var sum = nodeLength + info.prefixLength;\n              getResult({ node: node, sum: sum, info: info, i: i });\n            }\n          }\n        });\n\n        if (result.true > 0 || result.false > 0) {\n          if (result.true >= result.false) {\n            detected.push(true);\n          } else {\n            detected.push(false);\n          }\n        }\n      });\n\n      return detected;\n    }\n  };\n}();"}